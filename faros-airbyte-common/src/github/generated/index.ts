export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {[key: string]: unknown}> = {[K in keyof T]: T[K]};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {[key: string]: unknown}, K extends keyof T> = {
  [_ in K]?: never;
};
export type Incremental<T> =
  | T
  | {[P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: {input: string; output: string};
  String: {input: string; output: string};
  Boolean: {input: boolean; output: boolean};
  Int: {input: number; output: number};
  Float: {input: number; output: number};
  /** A (potentially binary) string encoded using base64. */
  Base64String: {input: string; output: string};
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: {input: string; output: string};
  /** An ISO-8601 encoded date string. */
  Date: {input: string; output: string};
  /** An ISO-8601 encoded UTC date string. */
  DateTime: {input: string; output: string};
  /** A Git object ID. */
  GitObjectID: {input: string; output: string};
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: {input: string; output: string};
  /** Git SSH string */
  GitSSHRemote: {input: string; output: string};
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: {input: string; output: string};
  /** A string containing HTML code. */
  HTML: {input: string; output: string};
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  PreciseDateTime: {input: string; output: string};
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: {input: string; output: string};
  /** A valid x509 certificate string */
  X509Certificate: {input: string; output: string};
};

/** Autogenerated input type of AbortQueuedMigrations */
export type AbortQueuedMigrationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that is running the migrations. */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated input type of AbortRepositoryMigration */
export type AbortRepositoryMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the migration to be aborted. */
  migrationId: Scalars['ID']['input'];
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated input type of AcceptEnterpriseMemberInvitation */
export type AcceptEnterpriseMemberInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** The actor's type. */
export enum ActorType {
  /** Indicates a team actor. */
  Team = 'TEAM',
  /** Indicates a user actor. */
  User = 'USER',
}

/** Autogenerated input type of AddAssigneesToAssignable */
export type AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID']['input'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddDiscussionComment */
export type AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars['ID']['input'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of AddDiscussionPollVote */
export type AddDiscussionPollVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion poll option to vote for. */
  pollOptionId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddEnterpriseOrganizationMember */
export type AddEnterpriseOrganizationMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise which owns the organization. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization the users will be added to. */
  organizationId: Scalars['ID']['input'];
  /** The role to assign the users in the organization */
  role?: InputMaybe<OrganizationMemberRole>;
  /** The IDs of the enterprise members to add. */
  userIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars['String']['input'];
};

/** Autogenerated input type of AddLabelsToLabelable */
export type AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']['input']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddProjectCard */
export type AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: InputMaybe<Scalars['ID']['input']>;
  /** The note on the card. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddProjectColumn */
export type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the column. */
  name: Scalars['String']['input'];
  /** The Node ID of the project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddProjectV2DraftIssue */
export type AddProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to add the draft issue to. */
  projectId: Scalars['ID']['input'];
  /**
   * The title of the draft issue. A project item can also be created by providing
   * the URL of an Issue or Pull Request if you have access.
   */
  title: Scalars['String']['input'];
};

/** Autogenerated input type of AddProjectV2ItemById */
export type AddProjectV2ItemByIdInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the Issue or Pull Request to add. */
  contentId: Scalars['ID']['input'];
  /** The ID of the Project to add the item to. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentInput = {
  /**
   * The text of the comment. This field is required
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The SHA of the commit to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;
  /**
   * The comment id to reply to.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  inReplyTo?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The relative path of the file to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  path?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line index in the diff to comment on.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  position?: InputMaybe<Scalars['Int']['input']>;
  /**
   * The node ID of the pull request reviewing
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The Node ID of the review to modify.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `pullRequestReviewId` will be removed. use
   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead
   * **Reason:** We are deprecating the addPullRequestReviewComment mutation
   */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of AddPullRequestReview */
export type AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The review line comments.
   *
   * **Upcoming Change on 2023-10-01 UTC**
   * **Description:** `comments` will be removed. use the `threads` argument instead
   * **Reason:** We are deprecating comment fields that use diff-relative positioning
   */
  comments?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The event to perform on the pull request review. */
  event?: InputMaybe<PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID']['input'];
  /** The review line comment threads. */
  threads?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewThread>>>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The line of the blob to which the thread refers, required for line-level
   * threads. The end of the line range for multi-line comments.
   */
  line?: InputMaybe<Scalars['Int']['input']>;
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<DiffSide>;
  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */
  subjectType?: InputMaybe<PullRequestReviewThreadSubjectType>;
};

/** Autogenerated input type of AddPullRequestReviewThreadReply */
export type AddPullRequestReviewThreadReplyInput = {
  /** The text of the reply. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending review to which the reply will belong. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
  /** The Node ID of the thread to which this reply is being written. */
  pullRequestReviewThreadId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddReaction */
export type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji to react with. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddStar */
export type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddUpvote */
export type AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of AddVerifiableDomain */
export type AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the domain */
  domain: Scalars['URI']['input'];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated input type of ApproveDeployments */
export type ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for approving deployments */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID']['input'];
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of ArchiveProjectV2Item */
export type ArchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to archive. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of ArchiveRepository */
export type ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID']['input'];
};

/** Ordering options for Audit Log connections. */
export type AuditLogOrder = {
  /** The ordering direction. */
  direction?: InputMaybe<OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: InputMaybe<AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export enum AuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = 'CREATED_AT',
}

/** Parameters to be used for the branch_name_pattern rule */
export type BranchNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/**
 * Information about a sponsorship to make for a user or organization with a GitHub
 * Sponsors profile, as part of sponsoring many users or organizations at once.
 */
export type BulkSponsorship = {
  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int']['input'];
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated input type of CancelEnterpriseMemberInvitation */
export type CancelEnterpriseMemberInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pending enterprise member invitation. */
  invitationId: Scalars['ID']['input'];
};

/** Autogenerated input type of CancelSponsorship */
export type CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of ChangeUserStatus */
export type ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: InputMaybe<Scalars['String']['input']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: InputMaybe<Scalars['Boolean']['input']>;
  /** A short description of your current status. */
  message?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: InputMaybe<Scalars['ID']['input']>;
};

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: CheckAnnotationLevel;
  /** The location of the annotation */
  location: CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String']['input'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String']['input'];
  /** Details about this annotation. */
  rawDetails?: InputMaybe<Scalars['String']['input']>;
  /** The title that represents the annotation. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an annotation's information level. */
export enum CheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = 'FAILURE',
  /** An annotation indicating some information. */
  Notice = 'NOTICE',
  /** An annotation indicating an ignorable error. */
  Warning = 'WARNING',
}

/** Information from a check run analysis to specific lines of code. */
export type CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The ending line of the range. */
  endLine: Scalars['Int']['input'];
  /** The starting column of the range. */
  startColumn?: InputMaybe<Scalars['Int']['input']>;
  /** The starting line of the range. */
  startLine: Scalars['Int']['input'];
};

/** The possible states for a check suite or run conclusion. */
export enum CheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check suite or run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check suite or run has failed. */
  Failure = 'FAILURE',
  /** The check suite or run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check suite or run was skipped. */
  Skipped = 'SKIPPED',
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check suite or run has failed at startup. */
  StartupFailure = 'STARTUP_FAILURE',
  /** The check suite or run has succeeded. */
  Success = 'SUCCESS',
  /** The check suite or run has timed out. */
  TimedOut = 'TIMED_OUT',
}

/** Possible further actions the integrator can perform. */
export type CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String']['input'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String']['input'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String']['input'];
};

/** The filters that are available when fetching check runs. */
export type CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check runs by this name. */
  checkName?: InputMaybe<Scalars['String']['input']>;
  /** Filters the check runs by this type. */
  checkType?: InputMaybe<CheckRunType>;
  /** Filters the check runs by these conclusions. */
  conclusions?: InputMaybe<Array<CheckConclusionState>>;
  /** Filters the check runs by this status. Superceded by statuses. */
  status?: InputMaybe<CheckStatusState>;
  /** Filters the check runs by this status. Overrides status. */
  statuses?: InputMaybe<Array<CheckStatusState>>;
};

/** Descriptive details about the check run. */
export type CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: InputMaybe<Array<CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: InputMaybe<Array<CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String']['input'];
  /** The details of the check run (supports Commonmark). */
  text?: InputMaybe<Scalars['String']['input']>;
  /** A title to provide for this check run. */
  title: Scalars['String']['input'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String']['input'];
  /** A short image description. */
  caption?: InputMaybe<Scalars['String']['input']>;
  /** The full URL of the image. */
  imageUrl: Scalars['URI']['input'];
};

/** The possible states of a check run in a status rollup. */
export enum CheckRunState {
  /** The check run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check run has been completed. */
  Completed = 'COMPLETED',
  /** The check run has failed. */
  Failure = 'FAILURE',
  /** The check run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check run is in pending state. */
  Pending = 'PENDING',
  /** The check run has been queued. */
  Queued = 'QUEUED',
  /** The check run was skipped. */
  Skipped = 'SKIPPED',
  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check run has failed at startup. */
  StartupFailure = 'STARTUP_FAILURE',
  /** The check run has succeeded. */
  Success = 'SUCCESS',
  /** The check run has timed out. */
  TimedOut = 'TIMED_OUT',
  /** The check run is in waiting state. */
  Waiting = 'WAITING',
}

/** The possible types of check runs. */
export enum CheckRunType {
  /** Every check run available. */
  All = 'ALL',
  /** The latest check run. */
  Latest = 'LATEST',
}

/** The possible states for a check suite or run status. */
export enum CheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run has been requested. */
  Requested = 'REQUESTED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING',
}

/** The auto-trigger preferences that are available for check suites. */
export type CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID']['input'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean']['input'];
};

/** The filters that are available when fetching check suites. */
export type CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: InputMaybe<Scalars['Int']['input']>;
  /** Filters the check suites by this name. */
  checkName?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of ClearLabelsFromLabelable */
export type ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated input type of ClearProjectV2ItemFieldValue */
export type ClearProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be cleared. */
  fieldId: Scalars['ID']['input'];
  /** The ID of the item to be cleared. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of CloneProject */
export type CloneProjectInput = {
  /** The description of the project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean']['input'];
  /** The name of the project. */
  name: Scalars['String']['input'];
  /** The visibility of the project, defaults to false (private). */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** The source project to clone. */
  sourceId: Scalars['ID']['input'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID']['input'];
};

/** Autogenerated input type of CloneTemplateRepository */
export type CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new repository. */
  name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID']['input'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID']['input'];
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** Autogenerated input type of CloseDiscussion */
export type CloseDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be closed. */
  discussionId: Scalars['ID']['input'];
  /** The reason why the discussion is being closed. */
  reason?: InputMaybe<DiscussionCloseReason>;
};

/** Autogenerated input type of CloseIssue */
export type CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID']['input'];
  /** The reason the issue is to be closed. */
  stateReason?: InputMaybe<IssueClosedStateReason>;
};

/** Autogenerated input type of ClosePullRequest */
export type ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID']['input'];
};

/**
 * Choose which tools must provide code scanning results before the reference is
 * updated. When configured, code scanning must be enabled and have results for
 * both the commit and the reference being updated.
 */
export type CodeScanningParametersInput = {
  /** Tools that must provide code scanning results for this rule to pass. */
  codeScanningTools: Array<CodeScanningToolInput>;
};

/** A tool that must provide code scanning results for this rule to pass. */
export type CodeScanningToolInput = {
  /**
   * The severity level at which code scanning results that raise alerts block a
   * reference update. For more information on alert severity levels, see "[About code scanning alerts](${externalDocsUrl}/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
   */
  alertsThreshold: Scalars['String']['input'];
  /**
   * The severity level at which code scanning results that raise security alerts
   * block a reference update. For more information on security severity levels,
   * see "[About code scanning alerts](${externalDocsUrl}/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
   */
  securityAlertsThreshold: Scalars['String']['input'];
  /** The name of a code scanning tool */
  tool: Scalars['String']['input'];
};

/** Collaborators affiliation level with a subject. */
export enum CollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = 'ALL',
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = 'DIRECT',
  /** All outside collaborators of an organization-owned subject. */
  Outside = 'OUTSIDE',
}

/** A comment author association with repository. */
export enum CommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = 'COLLABORATOR',
  /** Author has previously committed to the repository. */
  Contributor = 'CONTRIBUTOR',
  /** Author has not previously committed to GitHub. */
  FirstTimer = 'FIRST_TIMER',
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',
  /** Author is a placeholder for an unclaimed user. */
  Mannequin = 'MANNEQUIN',
  /** Author is a member of the organization that owns the repository. */
  Member = 'MEMBER',
  /** Author has no association with the repository. */
  None = 'NONE',
  /** Author is the owner of the repository. */
  Owner = 'OWNER',
}

/** The possible errors that will prevent a user from updating a comment. */
export enum CommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = 'ARCHIVED',
  /** You cannot update this comment */
  Denied = 'DENIED',
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = 'INSUFFICIENT_ACCESS',
  /** Unable to create comment because issue is locked. */
  Locked = 'LOCKED',
  /** You must be logged in to update this comment. */
  LoginRequired = 'LOGIN_REQUIRED',
  /** Repository is under maintenance. */
  Maintenance = 'MAINTENANCE',
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED',
}

/** Specifies an author for filtering Git commits. */
export type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: InputMaybe<Array<Scalars['String']['input']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Parameters to be used for the commit_author_email_pattern rule */
export type CommitAuthorEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** Ordering options for commit contribution connections. */
export type CommitContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order commit contributions. */
  field: CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export enum CommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = 'COMMIT_COUNT',
  /** Order commit contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT',
}

/** A message to include with a new commit */
export type CommitMessage = {
  /** The body of the message. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** The headline of the message. */
  headline: Scalars['String']['input'];
};

/** Parameters to be used for the commit_message_pattern rule */
export type CommitMessagePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * `repositoryNameWithOwner` and `branchName`.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using `repositoryNameWithOwner` and `branchName`:
 *
 *     {
 *       "repositoryNameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  branchName?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be updated. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The nameWithOwner of the repository to commit to. */
  repositoryNameWithOwner?: InputMaybe<Scalars['String']['input']>;
};

/** Parameters to be used for the committer_email_pattern rule */
export type CommitterEmailPatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** The status of a git comparison between two refs. */
export enum ComparisonStatus {
  /** The head ref is ahead of the base ref. */
  Ahead = 'AHEAD',
  /** The head ref is behind the base ref. */
  Behind = 'BEHIND',
  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */
  Diverged = 'DIVERGED',
  /** The head ref and base ref are identical. */
  Identical = 'IDENTICAL',
}

/** Varying levels of contributions from none to many. */
export enum ContributionLevel {
  /** Lowest 25% of days of contributions. */
  FirstQuartile = 'FIRST_QUARTILE',
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  FourthQuartile = 'FOURTH_QUARTILE',
  /** No contributions occurred. */
  None = 'NONE',
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  SecondQuartile = 'SECOND_QUARTILE',
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  ThirdQuartile = 'THIRD_QUARTILE',
}

/** Ordering options for contribution connections. */
export type ContributionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID']['input'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of ConvertProjectV2DraftIssueItemToIssue */
export type ConvertProjectV2DraftIssueItemToIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft issue ProjectV2Item to convert. */
  itemId: Scalars['ID']['input'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated input type of CopyProjectV2 */
export type CopyProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Include draft issues in the new project */
  includeDraftIssues?: InputMaybe<Scalars['Boolean']['input']>;
  /** The owner ID of the new project. */
  ownerId: Scalars['ID']['input'];
  /** The ID of the source Project to copy. */
  projectId: Scalars['ID']['input'];
  /** The title of the project. */
  title: Scalars['String']['input'];
};

/** Autogenerated input type of CreateAttributionInvitation */
export type CreateAttributionInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the owner scoping the reattributable data. */
  ownerId: Scalars['ID']['input'];
  /** The Node ID of the account owning the data to reattribute. */
  sourceId: Scalars['ID']['input'];
  /** The Node ID of the account which may claim the data. */
  targetId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String']['input'];
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID']['input'];
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<
    Array<Scalars['String']['input']>
  >;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated input type of CreateCheckRun */
export type CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['URI']['input']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID']['input'];
  /** The name of the check. */
  name: Scalars['String']['input'];
  /** Descriptive details about the run. */
  output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated input type of CreateCheckSuite */
export type CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID']['input'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateCommitOnBranch */
export type CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  branch: CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  expectedHeadOid: Scalars['GitObjectID']['input'];
  /** A description of changes to files in this commit. */
  fileChanges?: InputMaybe<FileChanges>;
  /** The commit message the be included with the commit. */
  message: CommitMessage;
};

/** Autogenerated input type of CreateDeployment */
export type CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Short description of the deployment. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Name for the target deployment environment. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** JSON payload with extra information about the deployment. */
  payload?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID']['input'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Specifies a task to execute. */
  task?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID']['input'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: InputMaybe<Scalars['String']['input']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: InputMaybe<Scalars['String']['input']>;
  /** The state of the deployment. */
  state: DeploymentStatusState;
};

/** Autogenerated input type of CreateDiscussion */
export type CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars['String']['input'];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the discussion. */
  title: Scalars['String']['input'];
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']['input']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the new organization. */
  login: Scalars['String']['input'];
  /** The profile name of the new organization. */
  profileName: Scalars['String']['input'];
};

/** Autogenerated input type of CreateEnvironment */
export type CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the environment. */
  name: Scalars['String']['input'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The title for the issue. */
  title: Scalars['String']['input'];
};

/** Autogenerated input type of CreateLabel */
export type CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String']['input'];
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the label. */
  name: Scalars['String']['input'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateLinkedBranch */
export type CreateLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to link to. */
  issueId: Scalars['ID']['input'];
  /** The name of the new branch. Defaults to issue number and title. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The commit SHA to base the new branch on. */
  oid: Scalars['GitObjectID']['input'];
  /** ID of the repository to create the branch in. Defaults to the issue repository. */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of CreateMigrationSource */
export type CreateMigrationSourceInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']['input']>;
  /** The migration source name. */
  name: Scalars['String']['input'];
  /** The ID of the organization that will own the migration source. */
  ownerId: Scalars['ID']['input'];
  /** The migration source type. */
  type: MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  name: Scalars['String']['input'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID']['input'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The name of the GitHub-provided template. */
  template?: InputMaybe<ProjectTemplate>;
};

/** Autogenerated input type of CreateProjectV2Field */
export type CreateProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The data type of the field. */
  dataType: ProjectV2CustomFieldType;
  /** The name of the field. */
  name: Scalars['String']['input'];
  /** The ID of the Project to create the field in. */
  projectId: Scalars['ID']['input'];
  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */
  singleSelectOptions?: InputMaybe<
    Array<ProjectV2SingleSelectFieldOptionInput>
  >;
};

/** Autogenerated input type of CreateProjectV2 */
export type CreateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID']['input'];
  /** The repository to link the project to. */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** The team to link the project to. The team will be granted read permissions. */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The title of the project. */
  title: Scalars['String']['input'];
};

/** Autogenerated input type of CreateProjectV2StatusUpdate */
export type CreateProjectV2StatusUpdateInput = {
  /** The body of the status update. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to create the status update in. */
  projectId: Scalars['ID']['input'];
  /** The start date of the status update. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** The status of the status update. */
  status?: InputMaybe<ProjectV2StatusUpdateStatus>;
  /** The target date of the status update. */
  targetDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated input type of CreatePullRequest */
export type CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String']['input'];
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String']['input'];
  /** The Node ID of the head repository. */
  headRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The title of the pull request. */
  title: Scalars['String']['input'];
};

/** Autogenerated input type of CreateRef */
export type CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String']['input'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['GitObjectID']['input'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of CreateRepository */
export type CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The name of the new repository. */
  name: Scalars['String']['input'];
  /** The ID of the owner for the new repository. */
  ownerId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates the repository's visibility level. */
  visibility: RepositoryVisibility;
};

/** Autogenerated input type of CreateRepositoryRuleset */
export type CreateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The set of conditions for this ruleset */
  conditions: RepositoryRuleConditionsInput;
  /** The enforcement level for this ruleset */
  enforcement: RuleEnforcement;
  /** The name of the ruleset. */
  name: Scalars['String']['input'];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<RepositoryRuleInput>>;
  /** The global relay id of the source in which a new ruleset should be created in. */
  sourceId: Scalars['ID']['input'];
  /** The target of the ruleset. */
  target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated input type of CreateSponsorsListing */
export type CreateSponsorsListingInput = {
  /**
   * The country or region where the sponsorable's bank account is located.
   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
   */
  billingCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The email address we should use to contact you about the GitHub Sponsors
   * profile being created. This will not be shared publicly. Must be a verified
   * email address already on your GitHub account. Only relevant when the
   * sponsorable is yourself. Defaults to your primary email address on file if omitted.
   */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /**
   * The username of the supported fiscal host's GitHub organization, if you want
   * to receive sponsorship payouts through a fiscal host rather than directly to a
   * bank account. For example, 'Open-Source-Collective' for Open Source Collective
   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
   * for more information.
   */
  fiscalHostLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The URL for your profile page on the fiscal host's website, e.g.,
   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.
   * Required if fiscalHostLogin is specified.
   */
  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']['input']>;
  /**
   * Provide an introduction to serve as the main focus that appears on your GitHub
   * Sponsors profile. It's a great opportunity to help potential sponsors learn
   * more about you, your work, and why their sponsorship is important to you.
   * GitHub-flavored Markdown is supported.
   */
  fullDescription?: InputMaybe<Scalars['String']['input']>;
  /**
   * The country or region where the sponsorable resides. This is for tax purposes.
   * Required if the sponsorable is yourself, ignored when sponsorableLogin
   * specifies an organization.
   */
  residenceCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;
  /**
   * The username of the organization to create a GitHub Sponsors profile for, if
   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated
   * user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateSponsorsTier */
export type CreateSponsorsTierInput = {
  /** The value of the new tier in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */
  description: Scalars['String']['input'];
  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */
  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether to make the tier available immediately for sponsors to choose.
   * Defaults to creating a draft tier that will not be publicly visible.
   */
  publish?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Optional ID of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization.
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Optional name of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization. Necessary if
   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
   */
  repositoryName?: InputMaybe<Scalars['String']['input']>;
  /**
   * Optional login of the organization owner of the private repository that
   * sponsors at this tier should gain read-only access to. Necessary if
   * repositoryName is given. Will be ignored if repositoryId is given.
   */
  repositoryOwnerLogin?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableLogin is not given.
   */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableId is not given.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** Optional message new sponsors at this tier will receive. */
  welcomeMessage?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateSponsorship */
export type CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  isRecurring?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  tierId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of CreateSponsorships */
export type CreateSponsorshipsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorables. Public visibility still does not reveal the dollar value of
   * the sponsorship.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorables. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether the sponsorships created should continue each billing cycle for the
   * sponsor (monthly or annually), versus lasting only a single month. Defaults to
   * one-time sponsorships.
   */
  recurring?: InputMaybe<Scalars['Boolean']['input']>;
  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */
  sponsorLogin: Scalars['String']['input'];
  /** The list of maintainers to sponsor and for how much apiece. */
  sponsorships: Array<BulkSponsorship>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type CreateTeamDiscussionCommentInput = {
  /**
   * The content of the comment. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The ID of the discussion to which the comment belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `discussionId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  discussionId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type CreateTeamDiscussionInput = {
  /**
   * The content of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `body` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization owners. If false or not specified, allows any organization member
   * to view this discussion.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `private` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  private?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the team to which the discussion belongs. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `teamId` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The title of the discussion. This field is required.
   *
   * **Upcoming Change on 2024-07-01 UTC**
   * **Description:** `title` will be removed. Follow the guide at
   * https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to
   * find a suitable replacement.
   * **Reason:** The Team Discussions feature is deprecated in favor of Organization Discussions.
   */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateUserList */
export type CreateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of the list */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the new list */
  name: Scalars['String']['input'];
};

/** Autogenerated input type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * The name of the suggested topic.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `name` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  name?: InputMaybe<Scalars['String']['input']>;
  /**
   * The reason why the suggested topic is declined.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `reason` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  reason?: InputMaybe<TopicSuggestionDeclineReason>;
  /**
   * The Node ID of the repository.
   *
   * **Upcoming Change on 2024-04-01 UTC**
   * **Description:** `repositoryId` will be removed.
   * **Reason:** Suggested topics are no longer supported
   */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** The possible base permissions for repositories. */
export enum DefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = 'ADMIN',
  /** No access */
  None = 'NONE',
  /** Can read repos by default */
  Read = 'READ',
  /** Can read and write repos by default */
  Write = 'WRITE',
}

/** Autogenerated input type of DeleteBranchProtectionRule */
export type DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of DeleteDeployment */
export type DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteDiscussionComment */
export type DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteDiscussion */
export type DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the discussion to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteEnvironment */
export type DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteIssueComment */
export type DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteIssue */
export type DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteLabel */
export type DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteLinkedBranch */
export type DeleteLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the linked branch */
  linkedBranchId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeletePackageVersion */
export type DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectCard */
export type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2Field */
export type DeleteProjectV2FieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to delete. */
  fieldId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2 */
export type DeleteProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to delete. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2Item */
export type DeleteProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be removed. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project from which the item should be removed. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2StatusUpdate */
export type DeleteProjectV2StatusUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the status update to be removed. */
  statusUpdateId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteProjectV2Workflow */
export type DeleteProjectV2WorkflowInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the workflow to be removed. */
  workflowId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeletePullRequestReview */
export type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteRef */
export type DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteRepositoryRuleset */
export type DeleteRepositoryRulesetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be deleted. */
  repositoryRulesetId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The discussion ID to delete. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteUserList */
export type DeleteUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the list to delete. */
  listId: Scalars['ID']['input'];
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars['ID']['input'];
};

/** The possible ecosystems of a dependency graph package. */
export enum DependencyGraphEcosystem {
  /** GitHub Actions */
  Actions = 'ACTIONS',
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Go modules */
  Go = 'GO',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Dart packages hosted at pub.dev */
  Pub = 'PUB',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS',
  /** Rust crates */
  Rust = 'RUST',
  /** Swift packages */
  Swift = 'SWIFT',
}

/** Ordering options for deployment connections */
export type DeploymentOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order deployments by. */
  field: DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export enum DeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = 'CREATED_AT',
}

/** The possible protection rule types. */
export enum DeploymentProtectionRuleType {
  /** Branch policy */
  BranchPolicy = 'BRANCH_POLICY',
  /** Required reviewers */
  RequiredReviewers = 'REQUIRED_REVIEWERS',
  /** Wait timer */
  WaitTimer = 'WAIT_TIMER',
}

/** The possible states for a deployment review. */
export enum DeploymentReviewState {
  /** The deployment was approved. */
  Approved = 'APPROVED',
  /** The deployment was rejected. */
  Rejected = 'REJECTED',
}

/** The possible states in which a deployment can be. */
export enum DeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = 'ABANDONED',
  /** The deployment is currently active. */
  Active = 'ACTIVE',
  /** An inactive transient deployment. */
  Destroyed = 'DESTROYED',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment has queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment is waiting. */
  Waiting = 'WAITING',
}

/** The possible states for a deployment status. */
export enum DeploymentStatusState {
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment is queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment is waiting. */
  Waiting = 'WAITING',
}

/** Autogenerated input type of DequeuePullRequest */
export type DequeuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the pull request to be dequeued. */
  id: Scalars['ID']['input'];
};

/** The possible sides of a diff. */
export enum DiffSide {
  /** The left side of the diff. */
  Left = 'LEFT',
  /** The right side of the diff. */
  Right = 'RIGHT',
}

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars['ID']['input'];
};

/** The possible reasons for closing a discussion. */
export enum DiscussionCloseReason {
  /** The discussion is a duplicate of another */
  Duplicate = 'DUPLICATE',
  /** The discussion is no longer relevant */
  Outdated = 'OUTDATED',
  /** The discussion has been resolved */
  Resolved = 'RESOLVED',
}

/** Ways in which lists of discussions can be ordered upon return. */
export type DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: OrderDirection;
  /** The field by which to order discussions. */
  field: DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export enum DiscussionOrderField {
  /** Order discussions by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order discussions by most recent modification time. */
  UpdatedAt = 'UPDATED_AT',
}

/** Ordering options for discussion poll option connections. */
export type DiscussionPollOptionOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order poll options by. */
  field: DiscussionPollOptionOrderField;
};

/** Properties by which discussion poll option connections can be ordered. */
export enum DiscussionPollOptionOrderField {
  /** Order poll options by the order that the poll author specified when creating the poll. */
  AuthoredOrder = 'AUTHORED_ORDER',
  /** Order poll options by the number of votes it has. */
  VoteCount = 'VOTE_COUNT',
}

/** The possible states of a discussion. */
export enum DiscussionState {
  /** A discussion that has been closed */
  Closed = 'CLOSED',
  /** A discussion that is open */
  Open = 'OPEN',
}

/** The possible state reasons of a discussion. */
export enum DiscussionStateReason {
  /** The discussion is a duplicate of another */
  Duplicate = 'DUPLICATE',
  /** The discussion is no longer relevant */
  Outdated = 'OUTDATED',
  /** The discussion was reopened */
  Reopened = 'REOPENED',
  /** The discussion has been resolved */
  Resolved = 'RESOLVED',
}

/** Autogenerated input type of DismissPullRequestReview */
export type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String']['input'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** The possible reasons that a Dependabot alert was dismissed. */
export enum DismissReason {
  /** A fix has already been started */
  FixStarted = 'FIX_STARTED',
  /** This alert is inaccurate or incorrect */
  Inaccurate = 'INACCURATE',
  /** Vulnerable code is not actually used */
  NotUsed = 'NOT_USED',
  /** No bandwidth to fix this */
  NoBandwidth = 'NO_BANDWIDTH',
  /** Risk is tolerable to this project */
  TolerableRisk = 'TOLERABLE_RISK',
}

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
export type DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The reason the Dependabot alert is being dismissed. */
  dismissReason: DismissReason;
  /** The Dependabot alert ID to dismiss. */
  repositoryVulnerabilityAlertId: Scalars['ID']['input'];
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String']['input'];
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int']['input'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String']['input'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int']['input'];
  /** Path to the file being commented on. */
  path: Scalars['String']['input'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']['input']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit body to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit message is ignored.
   */
  commitBody?: InputMaybe<Scalars['String']['input']>;
  /**
   * Commit headline to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit headline is ignored.
   */
  commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /**
   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
   * with a merge queue any input value for merge method is ignored.
   */
  mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated input type of EnqueuePullRequest */
export type EnqueuePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The expected head OID of the pull request. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** Add the pull request to the front of the queue. */
  jump?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to enqueue. */
  pullRequestId: Scalars['ID']['input'];
};

/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export enum EnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = 'CREATED_AT',
}

/** The possible administrator roles in an enterprise account. */
export enum EnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = 'BILLING_MANAGER',
  /** Represents an owner of the enterprise account. */
  Owner = 'OWNER',
}

/** The possible values for the enterprise allow private repository forking policy value. */
export enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  /** Members can fork a repository to an organization within this enterprise. */
  EnterpriseOrganizations = 'ENTERPRISE_ORGANIZATIONS',
  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */
  EnterpriseOrganizationsUserAccounts = 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS',
  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */
  Everywhere = 'EVERYWHERE',
  /** Members can fork a repository only within the same organization (intra-org). */
  SameOrganization = 'SAME_ORGANIZATION',
  /** Members can fork a repository to their user account or within the same organization. */
  SameOrganizationUserAccounts = 'SAME_ORGANIZATION_USER_ACCOUNTS',
  /** Members can fork a repository to their user account. */
  UserAccounts = 'USER_ACCOUNTS',
}

/** The possible values for the enterprise base repository permission setting. */
export enum EnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = 'ADMIN',
  /** Organization members will only be able to clone and pull public repositories. */
  None = 'NONE',
  /** Organizations in the enterprise choose base repository permissions for their members. */
  NoPolicy = 'NO_POLICY',
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = 'READ',
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = 'WRITE',
}

/** The possible values for an enabled/disabled enterprise setting. */
export enum EnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY',
}

/** The possible values for an enabled/no policy enterprise setting. */
export enum EnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY',
}

/** Ordering options for enterprise administrator invitation connections */
export type EnterpriseMemberInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise member invitations by. */
  field: EnterpriseMemberInvitationOrderField;
};

/** Properties by which enterprise member invitation connections can be ordered. */
export enum EnterpriseMemberInvitationOrderField {
  /** Order enterprise member invitations by creation time */
  CreatedAt = 'CREATED_AT',
}

/** Ordering options for enterprise member connections. */
export type EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise members by. */
  field: EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export enum EnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order enterprise members by login */
  Login = 'LOGIN',
}

/** The possible values for the enterprise members can create repositories setting. */
export enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Organization owners choose whether to allow members to create repositories. */
  NoPolicy = 'NO_POLICY',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will be able to create only public repositories. */
  Public = 'PUBLIC',
}

/** The possible values for the members can make purchases setting. */
export enum EnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
}

/** The possible values we have for filtering Platform::Objects::User#enterprises. */
export enum EnterpriseMembershipType {
  /** Returns all enterprises in which the user is an admin. */
  Admin = 'ADMIN',
  /** Returns all enterprises in which the user is a member, admin, or billing manager. */
  All = 'ALL',
  /** Returns all enterprises in which the user is a billing manager. */
  BillingManager = 'BILLING_MANAGER',
  /** Returns all enterprises in which the user is a member of an org that is owned by the enterprise. */
  OrgMembership = 'ORG_MEMBERSHIP',
}

/** Ordering options for enterprises. */
export type EnterpriseOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprises by. */
  field: EnterpriseOrderField;
};

/** Properties by which enterprise connections can be ordered. */
export enum EnterpriseOrderField {
  /** Order enterprises by name */
  Name = 'NAME',
}

/** Ordering options for Enterprise Server installation connections. */
export type EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export enum EnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order Enterprise Server installations by customer name */
  CustomerName = 'CUSTOMER_NAME',
  /** Order Enterprise Server installations by host name */
  HostName = 'HOST_NAME',
}

/** Ordering options for Enterprise Server user account email connections. */
export type EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order emails by. */
  field: EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export enum EnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = 'EMAIL',
}

/** Ordering options for Enterprise Server user account connections. */
export type EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts by. */
  field: EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export enum EnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = 'LOGIN',
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = 'REMOTE_CREATED_AT',
}

/** Ordering options for Enterprise Server user accounts upload connections. */
export type EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user accounts uploads by. */
  field: EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export enum EnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = 'CREATED_AT',
}

/** Synchronization state of the Enterprise Server user accounts upload */
export enum EnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = 'FAILURE',
  /** The synchronization of the upload is pending. */
  Pending = 'PENDING',
  /** The synchronization of the upload succeeded. */
  Success = 'SUCCESS',
}

/** The possible roles for enterprise membership. */
export enum EnterpriseUserAccountMembershipRole {
  /** The user is a member of an organization in the enterprise. */
  Member = 'MEMBER',
  /** The user is an owner of an organization in the enterprise. */
  Owner = 'OWNER',
  /**
   * The user is not an owner of the enterprise, and not a member or owner of any
   * organizations in the enterprise; only for EMU-enabled enterprises.
   */
  Unaffiliated = 'UNAFFILIATED',
}

/** The possible GitHub Enterprise deployments where this user can exist. */
export enum EnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = 'CLOUD',
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = 'SERVER',
}

/** Properties by which environments connections can be ordered */
export enum EnvironmentOrderField {
  /** Order environments by name. */
  Name = 'NAME',
}

/** Properties by which environments connections can be ordered */
export enum EnvironmentPinnedFilterField {
  /** All environments will be returned. */
  All = 'ALL',
  /** Environments exclude pinned will be returned */
  None = 'NONE',
  /** Only pinned environment will be returned */
  Only = 'ONLY',
}

/** Ordering options for environments */
export type Environments = {
  /** The direction in which to order environments by the specified field. */
  direction: OrderDirection;
  /** The field to order environments by. */
  field: EnvironmentOrderField;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type FileAddition = {
  /** The base64 encoded contents of the file */
  contents: Scalars['Base64String']['input'];
  /** The path in the repository where the file will be located */
  path: Scalars['String']['input'];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type FileChanges = {
  /** File to add or change. */
  additions?: InputMaybe<Array<FileAddition>>;
  /** Files to delete. */
  deletions?: InputMaybe<Array<FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type FileDeletion = {
  /** The path to delete */
  path: Scalars['String']['input'];
};

/**
 * Prevent commits that include files with specified file extensions from being
 * pushed to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type FileExtensionRestrictionParametersInput = {
  /** The file extensions that are restricted from being pushed to the commit graph. */
  restrictedFileExtensions: Array<Scalars['String']['input']>;
};

/**
 * Prevent commits that include changes in specified file paths from being pushed
 * to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type FilePathRestrictionParametersInput = {
  /** The file paths that are restricted from being pushed to the commit graph. */
  restrictedFilePaths: Array<Scalars['String']['input']>;
};

/** The possible viewed states of a file . */
export enum FileViewedState {
  /** The file has new changes since last viewed. */
  Dismissed = 'DISMISSED',
  /** The file has not been marked as viewed. */
  Unviewed = 'UNVIEWED',
  /** The file has been marked as viewed. */
  Viewed = 'VIEWED',
}

/** Autogenerated input type of FollowOrganization */
export type FollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to follow. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated input type of FollowUser */
export type FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to follow. */
  userId: Scalars['ID']['input'];
};

/** The possible funding platforms for repository funding links. */
export enum FundingPlatform {
  /** Buy Me a Coffee funding platform. */
  BuyMeACoffee = 'BUY_ME_A_COFFEE',
  /** Community Bridge funding platform. */
  CommunityBridge = 'COMMUNITY_BRIDGE',
  /** Custom funding platform. */
  Custom = 'CUSTOM',
  /** GitHub funding platform. */
  Github = 'GITHUB',
  /** IssueHunt funding platform. */
  Issuehunt = 'ISSUEHUNT',
  /** Ko-fi funding platform. */
  KoFi = 'KO_FI',
  /** LFX Crowdfunding funding platform. */
  LfxCrowdfunding = 'LFX_CROWDFUNDING',
  /** Liberapay funding platform. */
  Liberapay = 'LIBERAPAY',
  /** Open Collective funding platform. */
  OpenCollective = 'OPEN_COLLECTIVE',
  /** Patreon funding platform. */
  Patreon = 'PATREON',
  /** Polar funding platform. */
  Polar = 'POLAR',
  /** Tidelift funding platform. */
  Tidelift = 'TIDELIFT',
}

/** Ordering options for gist connections */
export type GistOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum GistOrderField {
  /** Order gists by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order gists by push time */
  PushedAt = 'PUSHED_AT',
  /** Order gists by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** The privacy of a Gist */
export enum GistPrivacy {
  /** Gists that are public and secret */
  All = 'ALL',
  /** Public */
  Public = 'PUBLIC',
  /** Secret */
  Secret = 'SECRET',
}

/** The state of a Git signature. */
export enum GitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = 'BAD_CERT',
  /** Invalid email used for signing */
  BadEmail = 'BAD_EMAIL',
  /** Signing key expired */
  ExpiredKey = 'EXPIRED_KEY',
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = 'GPGVERIFY_ERROR',
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',
  /** Invalid signature */
  Invalid = 'INVALID',
  /** Malformed signature */
  MalformedSig = 'MALFORMED_SIG',
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = 'NOT_SIGNING_KEY',
  /** Email used for signing not known to GitHub */
  NoUser = 'NO_USER',
  /** Valid signature, though certificate revocation check failed */
  OcspError = 'OCSP_ERROR',
  /** Valid signature, pending certificate revocation checking */
  OcspPending = 'OCSP_PENDING',
  /** One or more certificates in chain has been revoked */
  OcspRevoked = 'OCSP_REVOKED',
  /** Key used for signing not known to GitHub */
  UnknownKey = 'UNKNOWN_KEY',
  /** Unknown signature type */
  UnknownSigType = 'UNKNOWN_SIG_TYPE',
  /** Unsigned */
  Unsigned = 'UNSIGNED',
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = 'UNVERIFIED_EMAIL',
  /** Valid signature and verified by GitHub */
  Valid = 'VALID',
}

/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */
export type GrantEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to grant the migrator role */
  login: Scalars['String']['input'];
};

/** Autogenerated input type of GrantMigratorRole */
export type GrantMigratorRoleInput = {
  /** The user login or Team slug to grant the migrator role. */
  actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID']['input'];
};

/** The possible states in which authentication can be configured with an identity provider. */
export enum IdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = 'CONFIGURED',
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = 'ENFORCED',
  /** Authentication with an identity provider is not configured. */
  Unconfigured = 'UNCONFIGURED',
}

/** Autogenerated input type of ImportProject */
export type ImportProjectInput = {
  /** The description of Project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String']['input'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String']['input'];
  /** Whether the Project is public or not. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The email of the person to invite as an administrator. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a user to invite as an administrator. */
  invitee?: InputMaybe<Scalars['String']['input']>;
  /** The role of the administrator. */
  role?: InputMaybe<EnterpriseAdministratorRole>;
};

/** Autogenerated input type of InviteEnterpriseMember */
export type InviteEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The email of the person to invite as an unaffiliated member. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which you want to invite an unaffiliated member. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a user to invite as an unaffiliated member. */
  invitee?: InputMaybe<Scalars['String']['input']>;
};

/** The possible values for the IP allow list enabled setting. */
export enum IpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED',
}

/** Ordering options for IP allow list entry connections. */
export type IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order IP allow list entries by. */
  field: IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export enum IpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = 'ALLOW_LIST_VALUE',
  /** Order IP allow list entries by creation time. */
  CreatedAt = 'CREATED_AT',
}

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export enum IpAllowListForInstalledAppsEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED',
}

/** The possible state reasons of a closed issue. */
export enum IssueClosedStateReason {
  /** An issue that has been closed as completed */
  Completed = 'COMPLETED',
  /** An issue that has been closed as not planned */
  NotPlanned = 'NOT_PLANNED',
}

/** Ways in which lists of issue comments can be ordered upon return. */
export type IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issue comments by. */
  field: IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export enum IssueCommentOrderField {
  /** Order issue comments by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** Ways in which to filter lists of issues. */
export type IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: InputMaybe<Scalars['String']['input']>;
  /** List issues created by given name. */
  createdBy?: InputMaybe<Scalars['String']['input']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: InputMaybe<Array<Scalars['String']['input']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its database ID. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: InputMaybe<Scalars['String']['input']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** List issues that have been updated at or after the given date. */
  since?: InputMaybe<Scalars['DateTime']['input']>;
  /** List issues filtered by the list of states given. */
  states?: InputMaybe<Array<IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Ways in which lists of issues can be ordered upon return. */
export type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issues by. */
  field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum IssueOrderField {
  /** Order issues by comment count */
  Comments = 'COMMENTS',
  /** Order issues by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order issues by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** The possible states of an issue. */
export enum IssueState {
  /** An issue that has been closed */
  Closed = 'CLOSED',
  /** An issue that is still open */
  Open = 'OPEN',
}

/** The possible state reasons of an issue. */
export enum IssueStateReason {
  /** An issue that has been closed as completed */
  Completed = 'COMPLETED',
  /** An issue that has been closed as not planned */
  NotPlanned = 'NOT_PLANNED',
  /** An issue that has been reopened */
  Reopened = 'REOPENED',
}

/** The possible item types found in a timeline. */
export enum IssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT',
}

/** Ways in which lists of labels can be ordered upon return. */
export type LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: OrderDirection;
  /** The field in which to order labels by. */
  field: LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export enum LabelOrderField {
  /** Order labels by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order labels by name */
  Name = 'NAME',
}

/** Ordering options for language connections. */
export type LanguageOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order languages by. */
  field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum LanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = 'SIZE',
}

/** Autogenerated input type of LinkProjectV2ToRepository */
export type LinkProjectV2ToRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the repository to link to the project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of LinkProjectV2ToTeam */
export type LinkProjectV2ToTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to link to the team. */
  projectId: Scalars['ID']['input'];
  /** The ID of the team to link to the project. */
  teamId: Scalars['ID']['input'];
};

/** Autogenerated input type of LinkRepositoryToProject */
export type LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID']['input'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of LockLockable */
export type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A reason for why the item will be locked. */
  lockReason?: InputMaybe<LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars['ID']['input'];
};

/** The possible reasons that an issue or pull request was locked. */
export enum LockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = 'OFF_TOPIC',
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = 'RESOLVED',
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = 'SPAM',
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = 'TOO_HEATED',
}

/** Ordering options for mannequins. */
export type MannequinOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order mannequins by. */
  field: MannequinOrderField;
};

/** Properties by which mannequins can be ordered. */
export enum MannequinOrderField {
  /** Order mannequins why when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order mannequins alphabetically by their source login. */
  Login = 'LOGIN',
}

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of MarkFileAsViewed */
export type MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as viewed */
  path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated input type of MarkNotificationAsDone */
export type MarkNotificationAsDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The NotificationThread id. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of MarkProjectV2AsTemplate */
export type MarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to mark as a template. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID']['input'];
};

/**
 * Prevent commits that include file paths that exceed a specified character limit
 * from being pushed to the commit graph. NOTE: This rule is in beta and subject to change
 */
export type MaxFilePathLengthParametersInput = {
  /** The maximum amount of characters allowed in file paths */
  maxFilePathLength: Scalars['Int']['input'];
};

/**
 * Prevent commits that exceed a specified file size limit from being pushed to the
 * commit. NOTE: This rule is in beta and subject to change
 */
export type MaxFileSizeParametersInput = {
  /** The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS). */
  maxFileSize: Scalars['Int']['input'];
};

/** Autogenerated input type of MergeBranch */
export type MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String']['input'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID']['input'];
};

/** The possible default commit messages for merges. */
export enum MergeCommitMessage {
  /** Default to a blank commit message. */
  Blank = 'BLANK',
  /** Default to the pull request's body. */
  PrBody = 'PR_BODY',
  /** Default to the pull request's title. */
  PrTitle = 'PR_TITLE',
}

/** The possible default commit titles for merges. */
export enum MergeCommitTitle {
  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */
  MergeMessage = 'MERGE_MESSAGE',
  /** Default to the pull request's title. */
  PrTitle = 'PR_TITLE',
}

/** Autogenerated input type of MergePullRequest */
export type MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: InputMaybe<Scalars['String']['input']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars['String']['input']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID']['input'];
};

/** The possible states for a merge queue entry. */
export enum MergeQueueEntryState {
  /** The entry is currently waiting for checks to pass. */
  AwaitingChecks = 'AWAITING_CHECKS',
  /** The entry is currently locked. */
  Locked = 'LOCKED',
  /** The entry is currently mergeable. */
  Mergeable = 'MERGEABLE',
  /** The entry is currently queued. */
  Queued = 'QUEUED',
  /** The entry is currently unmergeable. */
  Unmergeable = 'UNMERGEABLE',
}

/** The possible merging strategies for a merge queue. */
export enum MergeQueueMergingStrategy {
  /** Entries only allowed to merge if they are passing. */
  Allgreen = 'ALLGREEN',
  /** Failing Entires are allowed to merge if they are with a passing entry. */
  Headgreen = 'HEADGREEN',
}

/** Detailed status information about a pull request merge. */
export enum MergeStateStatus {
  /** The head ref is out of date. */
  Behind = 'BEHIND',
  /** The merge is blocked. */
  Blocked = 'BLOCKED',
  /** Mergeable and passing commit status. */
  Clean = 'CLEAN',
  /** The merge commit cannot be cleanly created. */
  Dirty = 'DIRTY',
  /**
   * The merge is blocked due to the pull request being a draft.
   * @deprecated DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.
   */
  Draft = 'DRAFT',
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = 'HAS_HOOKS',
  /** The state cannot currently be determined. */
  Unknown = 'UNKNOWN',
  /** Mergeable with non-passing commit status. */
  Unstable = 'UNSTABLE',
}

/** Whether or not a PullRequest can be merged. */
export enum MergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = 'CONFLICTING',
  /** The pull request can be merged. */
  Mergeable = 'MERGEABLE',
  /** The mergeability of the pull request is still being calculated. */
  Unknown = 'UNKNOWN',
}

/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */
export enum MigrationSourceType {
  /** An Azure DevOps migration source. */
  AzureDevops = 'AZURE_DEVOPS',
  /** A Bitbucket Server migration source. */
  BitbucketServer = 'BITBUCKET_SERVER',
  /** A GitHub Migration API source. */
  GithubArchive = 'GITHUB_ARCHIVE',
}

/** The GitHub Enterprise Importer (GEI) migration state. */
export enum MigrationState {
  /** The migration has failed. */
  Failed = 'FAILED',
  /** The migration has invalid credentials. */
  FailedValidation = 'FAILED_VALIDATION',
  /** The migration is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The migration has not started. */
  NotStarted = 'NOT_STARTED',
  /** The migration needs to have its credentials validated. */
  PendingValidation = 'PENDING_VALIDATION',
  /** The migration has been queued. */
  Queued = 'QUEUED',
  /** The migration has succeeded. */
  Succeeded = 'SUCCEEDED',
}

/** Ordering options for milestone connections. */
export type MilestoneOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order milestones by. */
  field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum MilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order milestones by when they are due. */
  DueDate = 'DUE_DATE',
  /** Order milestones by their number. */
  Number = 'NUMBER',
  /** Order milestones by when they were last updated. */
  UpdatedAt = 'UPDATED_AT',
}

/** The possible states of a milestone. */
export enum MilestoneState {
  /** A milestone that has been closed. */
  Closed = 'CLOSED',
  /** A milestone that is still open. */
  Open = 'OPEN',
}

/** Autogenerated input type of MinimizeComment */
export type MinimizeCommentInput = {
  /** The classification of comment */
  classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of MoveProjectCard */
export type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: InputMaybe<Scalars['ID']['input']>;
  /** The id of the card to move. */
  cardId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID']['input'];
};

/** Autogenerated input type of MoveProjectColumn */
export type MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the column to move. */
  columnId: Scalars['ID']['input'];
};

/** The possible values for the notification restriction setting. */
export enum NotificationRestrictionSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED',
}

/** The OIDC identity provider type */
export enum OidcProviderType {
  /** Azure Active Directory */
  Aad = 'AAD',
}

/** The state of an OAuth application when it was created. */
export enum OauthApplicationCreateAuditEntryState {
  /** The OAuth application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION',
  /** The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED',
}

/** The corresponding operation type for the action */
export enum OperationType {
  /** An existing resource was accessed */
  Access = 'ACCESS',
  /** A resource performed an authentication event */
  Authentication = 'AUTHENTICATION',
  /** A new resource was created */
  Create = 'CREATE',
  /** An existing resource was modified */
  Modify = 'MODIFY',
  /** An existing resource was removed */
  Remove = 'REMOVE',
  /** An existing resource was restored */
  Restore = 'RESTORE',
  /** An existing resource was transferred between multiple resources */
  Transfer = 'TRANSFER',
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC',
}

/** The permissions available to members on an Organization. */
export enum OrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ',
}

/** The billing plans available for organizations. */
export enum OrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = 'BUSINESS',
  /** Enterprise Cloud Plan */
  BusinessPlus = 'BUSINESS_PLUS',
  /** Free Plan */
  Free = 'FREE',
  /** Tiered Per Seat Plan */
  TieredPerSeat = 'TIERED_PER_SEAT',
  /** Legacy Unlimited Plan */
  Unlimited = 'UNLIMITED',
}

/** Ordering options for an organization's enterprise owner connections. */
export type OrgEnterpriseOwnerOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order enterprise owners by. */
  field: OrgEnterpriseOwnerOrderField;
};

/** Properties by which enterprise owners can be ordered. */
export enum OrgEnterpriseOwnerOrderField {
  /** Order enterprise owners by login. */
  Login = 'LOGIN',
}

/** The reason a billing manager was removed from an Organization. */
export enum OrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
}

/** The type of membership a user has with an Organization. */
export enum OrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization owners have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization owners can delete the organization
   * and all of its repositories.
   */
  Admin = 'ADMIN',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = 'DIRECT_MEMBER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /** A suspended member. */
  Suspended = 'SUSPENDED',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = 'UNAFFILIATED',
}

/** The reason a member was removed from an Organization. */
export enum OrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** User account has been deleted */
  UserAccountDeleted = 'USER_ACCOUNT_DELETED',
}

/** The type of membership a user has with an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = 'UNAFFILIATED',
}

/** The reason an outside collaborator was removed from an Organization. */
export enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
}

/** The default permission a repository can have in an Organization. */
export enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** No default permission value. */
  None = 'NONE',
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone and push to repositories. */
  Write = 'WRITE',
}

/** The permissions available to members on an Organization. */
export enum OrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ',
}

/** The permissions available for repository creation on an Organization. */
export enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = 'ALL',
  /** All organization members are restricted from creating internal repositories. */
  Internal = 'INTERNAL',
  /** All organization members are allowed to create any repositories. */
  None = 'NONE',
  /** All organization members are restricted from creating private repositories. */
  Private = 'PRIVATE',
  /** All organization members are restricted from creating private or internal repositories. */
  PrivateInternal = 'PRIVATE_INTERNAL',
  /** All organization members are restricted from creating public repositories. */
  Public = 'PUBLIC',
  /** All organization members are restricted from creating public or internal repositories. */
  PublicInternal = 'PUBLIC_INTERNAL',
  /** All organization members are restricted from creating public or private repositories. */
  PublicPrivate = 'PUBLIC_PRIVATE',
}

/** The possible organization invitation roles. */
export enum OrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = 'ADMIN',
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = 'BILLING_MANAGER',
  /** The user is invited to be a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** The user's previous role will be reinstated. */
  Reinstate = 'REINSTATE',
}

/** The possible organization invitation sources. */
export enum OrganizationInvitationSource {
  /** The invitation was created from the web interface or from API */
  Member = 'MEMBER',
  /** The invitation was created from SCIM */
  Scim = 'SCIM',
  /** The invitation was sent before this feature was added */
  Unknown = 'UNKNOWN',
}

/** The possible organization invitation types. */
export enum OrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = 'EMAIL',
  /** The invitation was to an existing user. */
  User = 'USER',
}

/** The possible roles within an organization for its members. */
export enum OrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = 'ADMIN',
  /** The user is a member of the organization. */
  Member = 'MEMBER',
}

/** The possible values for the members can create repositories setting on an organization. */
export enum OrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Members will be able to create only internal repositories. */
  Internal = 'INTERNAL',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
}

/** The Octoshift Organization migration state. */
export enum OrganizationMigrationState {
  /** The Octoshift migration has failed. */
  Failed = 'FAILED',
  /** The Octoshift migration has invalid credentials. */
  FailedValidation = 'FAILED_VALIDATION',
  /** The Octoshift migration is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The Octoshift migration has not started. */
  NotStarted = 'NOT_STARTED',
  /** The Octoshift migration needs to have its credentials validated. */
  PendingValidation = 'PENDING_VALIDATION',
  /** The Octoshift migration is performing post repository migrations. */
  PostRepoMigration = 'POST_REPO_MIGRATION',
  /** The Octoshift migration is performing pre repository migrations. */
  PreRepoMigration = 'PRE_REPO_MIGRATION',
  /** The Octoshift migration has been queued. */
  Queued = 'QUEUED',
  /** The Octoshift org migration is performing repository migrations. */
  RepoMigration = 'REPO_MIGRATION',
  /** The Octoshift migration has succeeded. */
  Succeeded = 'SUCCEEDED',
}

/** Ordering options for organization connections. */
export type OrganizationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order organizations by. */
  field: OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export enum OrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order organizations by login */
  Login = 'LOGIN',
}

/** Ways in which lists of package files can be ordered upon return. */
export type PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package files by. */
  field?: InputMaybe<PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export enum PackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = 'CREATED_AT',
}

/** Ways in which lists of packages can be ordered upon return. */
export type PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order packages by. */
  field?: InputMaybe<PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export enum PackageOrderField {
  /** Order packages by creation time */
  CreatedAt = 'CREATED_AT',
}

/** The possible types of a package. */
export enum PackageType {
  /** A debian package. */
  Debian = 'DEBIAN',
  /**
   * A docker image.
   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.
   */
  Docker = 'DOCKER',
  /**
   * A maven package.
   * @deprecated MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC.
   */
  Maven = 'MAVEN',
  /**
   * An npm package.
   * @deprecated NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.
   */
  Npm = 'NPM',
  /**
   * A nuget package.
   * @deprecated NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.
   */
  Nuget = 'NUGET',
  /** A python package. */
  Pypi = 'PYPI',
  /**
   * A rubygems package.
   * @deprecated RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC.
   */
  Rubygems = 'RUBYGEMS',
}

/** Ways in which lists of package versions can be ordered upon return. */
export type PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: InputMaybe<OrderDirection>;
  /** The field in which to order package versions by. */
  field?: InputMaybe<PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export enum PackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = 'CREATED_AT',
}

/** The possible types of patch statuses. */
export enum PatchStatus {
  /** The file was added. Git status 'A'. */
  Added = 'ADDED',
  /** The file's type was changed. Git status 'T'. */
  Changed = 'CHANGED',
  /** The file was copied. Git status 'C'. */
  Copied = 'COPIED',
  /** The file was deleted. Git status 'D'. */
  Deleted = 'DELETED',
  /** The file's contents were changed. Git status 'M'. */
  Modified = 'MODIFIED',
  /** The file was renamed. Git status 'R'. */
  Renamed = 'RENAMED',
}

/** Autogenerated input type of PinEnvironment */
export type PinEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the environment to modify */
  environmentId: Scalars['ID']['input'];
  /** The desired state of the environment. If true, environment will be pinned. If false, it will be unpinned. */
  pinned: Scalars['Boolean']['input'];
};

/** Autogenerated input type of PinIssue */
export type PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID']['input'];
};

/** Represents items that can be pinned to a profile page or dashboard. */
export enum PinnableItemType {
  /** A gist. */
  Gist = 'GIST',
  /** An issue. */
  Issue = 'ISSUE',
  /** An organization. */
  Organization = 'ORGANIZATION',
  /** A project. */
  Project = 'PROJECT',
  /** A pull request. */
  PullRequest = 'PULL_REQUEST',
  /** A repository. */
  Repository = 'REPOSITORY',
  /** A team. */
  Team = 'TEAM',
  /** A user. */
  User = 'USER',
}

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionGradient {
  /** A gradient of blue to mint */
  BlueMint = 'BLUE_MINT',
  /** A gradient of blue to purple */
  BluePurple = 'BLUE_PURPLE',
  /** A gradient of pink to blue */
  PinkBlue = 'PINK_BLUE',
  /** A gradient of purple to coral */
  PurpleCoral = 'PURPLE_CORAL',
  /** A gradient of red to orange */
  RedOrange = 'RED_ORANGE',
}

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export enum PinnedDiscussionPattern {
  /** An upward-facing chevron pattern */
  ChevronUp = 'CHEVRON_UP',
  /** A hollow dot pattern */
  Dot = 'DOT',
  /** A solid dot pattern */
  DotFill = 'DOT_FILL',
  /** A heart pattern */
  HeartFill = 'HEART_FILL',
  /** A plus sign pattern */
  Plus = 'PLUS',
  /** A lightning bolt pattern */
  Zap = 'ZAP',
}

/** Ordering options for pinned environments */
export type PinnedEnvironmentOrder = {
  /** The direction in which to order pinned environments by the specified field. */
  direction: OrderDirection;
  /** The field to order pinned environments by. */
  field: PinnedEnvironmentOrderField;
};

/** Properties by which pinned environments connections can be ordered */
export enum PinnedEnvironmentOrderField {
  /** Order pinned environments by position */
  Position = 'POSITION',
}

/** The possible archived states of a project card. */
export enum ProjectCardArchivedState {
  /** A project card that is archived */
  Archived = 'ARCHIVED',
  /** A project card that is not archived */
  NotArchived = 'NOT_ARCHIVED',
}

/** An issue or PR and its owning repository to be used in a project card. */
export type ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int']['input'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String']['input'];
};

/** Various content states of a ProjectCard */
export enum ProjectCardState {
  /** The card has content only. */
  ContentOnly = 'CONTENT_ONLY',
  /** The card has a note only. */
  NoteOnly = 'NOTE_ONLY',
  /** The card is redacted. */
  Redacted = 'REDACTED',
}

/** A project column and a list of its issues and PRs. */
export type ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String']['input'];
  /** A list of issues and pull requests in the column. */
  issues?: InputMaybe<Array<ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int']['input'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum ProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = 'DONE',
  /** The column contains cards which are currently being worked on */
  InProgress = 'IN_PROGRESS',
  /** The column contains cards still to be worked on */
  Todo = 'TODO',
}

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum ProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order projects by name */
  Name = 'NAME',
  /** Order projects by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** State of the project; either 'open' or 'closed' */
export enum ProjectState {
  /** The project is closed. */
  Closed = 'CLOSED',
  /** The project is open. */
  Open = 'OPEN',
}

/** GitHub-provided templates for Projects */
export enum ProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = 'BASIC_KANBAN',
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = 'BUG_TRIAGE',
}

/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */
export type ProjectV2Collaborator = {
  /** The role to grant the collaborator */
  role: ProjectV2Roles;
  /** The ID of the team as a collaborator. */
  teamId?: InputMaybe<Scalars['ID']['input']>;
  /** The ID of the user as a collaborator. */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** The type of a project field. */
export enum ProjectV2CustomFieldType {
  /** Date */
  Date = 'DATE',
  /** Number */
  Number = 'NUMBER',
  /** Single Select */
  SingleSelect = 'SINGLE_SELECT',
  /** Text */
  Text = 'TEXT',
}

/** Ordering options for project v2 field connections */
export type ProjectV2FieldOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 fields by. */
  field: ProjectV2FieldOrderField;
};

/** Properties by which project v2 field connections can be ordered. */
export enum ProjectV2FieldOrderField {
  /** Order project v2 fields by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order project v2 fields by name */
  Name = 'NAME',
  /** Order project v2 fields by position */
  Position = 'POSITION',
}

/** The type of a project field. */
export enum ProjectV2FieldType {
  /** Assignees */
  Assignees = 'ASSIGNEES',
  /** Date */
  Date = 'DATE',
  /** Iteration */
  Iteration = 'ITERATION',
  /** Labels */
  Labels = 'LABELS',
  /** Linked Pull Requests */
  LinkedPullRequests = 'LINKED_PULL_REQUESTS',
  /** Milestone */
  Milestone = 'MILESTONE',
  /** Number */
  Number = 'NUMBER',
  /** Repository */
  Repository = 'REPOSITORY',
  /** Reviewers */
  Reviewers = 'REVIEWERS',
  /** Single Select */
  SingleSelect = 'SINGLE_SELECT',
  /** Text */
  Text = 'TEXT',
  /** Title */
  Title = 'TITLE',
  /** Tracked by */
  TrackedBy = 'TRACKED_BY',
  /** Tracks */
  Tracks = 'TRACKS',
}

/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */
export type ProjectV2FieldValue = {
  /** The ISO 8601 date to set on the field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** The id of the iteration to set on the field. */
  iterationId?: InputMaybe<Scalars['String']['input']>;
  /** The number to set on the field. */
  number?: InputMaybe<Scalars['Float']['input']>;
  /** The id of the single select option to set on the field. */
  singleSelectOptionId?: InputMaybe<Scalars['String']['input']>;
  /** The text to set on the field. */
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Ways in which to filter lists of projects. */
export type ProjectV2Filters = {
  /** List project v2 filtered by the state given. */
  state?: InputMaybe<ProjectV2State>;
};

/** Ordering options for project v2 item field value connections */
export type ProjectV2ItemFieldValueOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 item field values by. */
  field: ProjectV2ItemFieldValueOrderField;
};

/** Properties by which project v2 item field value connections can be ordered. */
export enum ProjectV2ItemFieldValueOrderField {
  /** Order project v2 item field values by the their position in the project */
  Position = 'POSITION',
}

/** Ordering options for project v2 item connections */
export type ProjectV2ItemOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 items by. */
  field: ProjectV2ItemOrderField;
};

/** Properties by which project v2 item connections can be ordered. */
export enum ProjectV2ItemOrderField {
  /** Order project v2 items by the their position in the project */
  Position = 'POSITION',
}

/** The type of a project item. */
export enum ProjectV2ItemType {
  /** Draft Issue */
  DraftIssue = 'DRAFT_ISSUE',
  /** Issue */
  Issue = 'ISSUE',
  /** Pull Request */
  PullRequest = 'PULL_REQUEST',
  /** Redacted Item */
  Redacted = 'REDACTED',
}

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectV2Order = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectV2OrderField;
};

/** Properties by which projects can be ordered. */
export enum ProjectV2OrderField {
  /** The project's date and time of creation */
  CreatedAt = 'CREATED_AT',
  /** The project's number */
  Number = 'NUMBER',
  /** The project's title */
  Title = 'TITLE',
  /** The project's date and time of update */
  UpdatedAt = 'UPDATED_AT',
}

/** The possible roles of a collaborator on a project. */
export enum ProjectV2Roles {
  /** The collaborator can view, edit, and maange the settings of the project */
  Admin = 'ADMIN',
  /** The collaborator has no direct access to the project */
  None = 'NONE',
  /** The collaborator can view the project */
  Reader = 'READER',
  /** The collaborator can view and edit the project */
  Writer = 'WRITER',
}

/** The display color of a single-select field option. */
export enum ProjectV2SingleSelectFieldOptionColor {
  /** BLUE */
  Blue = 'BLUE',
  /** GRAY */
  Gray = 'GRAY',
  /** GREEN */
  Green = 'GREEN',
  /** ORANGE */
  Orange = 'ORANGE',
  /** PINK */
  Pink = 'PINK',
  /** PURPLE */
  Purple = 'PURPLE',
  /** RED */
  Red = 'RED',
  /** YELLOW */
  Yellow = 'YELLOW',
}

/** Represents a single select field option */
export type ProjectV2SingleSelectFieldOptionInput = {
  /** The display color of the option */
  color: ProjectV2SingleSelectFieldOptionColor;
  /** The description text of the option */
  description: Scalars['String']['input'];
  /** The name of the option */
  name: Scalars['String']['input'];
};

/** The possible states of a project v2. */
export enum ProjectV2State {
  /** A project v2 that has been closed */
  Closed = 'CLOSED',
  /** A project v2 that is still open */
  Open = 'OPEN',
}

/** Ways in which project v2 status updates can be ordered. */
export type ProjectV2StatusOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: ProjectV2StatusUpdateOrderField;
};

/** Properties by which project v2 status updates can be ordered. */
export enum ProjectV2StatusUpdateOrderField {
  /** Allows chronological ordering of project v2 status updates. */
  CreatedAt = 'CREATED_AT',
}

/** The possible statuses of a project v2. */
export enum ProjectV2StatusUpdateStatus {
  /** A project v2 that is at risk and encountering some challenges. */
  AtRisk = 'AT_RISK',
  /** A project v2 that is complete. */
  Complete = 'COMPLETE',
  /** A project v2 that is inactive. */
  Inactive = 'INACTIVE',
  /** A project v2 that is off track and needs attention. */
  OffTrack = 'OFF_TRACK',
  /** A project v2 that is on track with no risks. */
  OnTrack = 'ON_TRACK',
}

/** The layout of a project v2 view. */
export enum ProjectV2ViewLayout {
  /** Board layout */
  BoardLayout = 'BOARD_LAYOUT',
  /** Roadmap layout */
  RoadmapLayout = 'ROADMAP_LAYOUT',
  /** Table layout */
  TableLayout = 'TABLE_LAYOUT',
}

/** Ordering options for project v2 view connections */
export type ProjectV2ViewOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 views by. */
  field: ProjectV2ViewOrderField;
};

/** Properties by which project v2 view connections can be ordered. */
export enum ProjectV2ViewOrderField {
  /** Order project v2 views by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order project v2 views by name */
  Name = 'NAME',
  /** Order project v2 views by position */
  Position = 'POSITION',
}

/** Ordering options for project v2 workflows connections */
export type ProjectV2WorkflowOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order the project v2 workflows by. */
  field: ProjectV2WorkflowsOrderField;
};

/** Properties by which project workflows can be ordered. */
export enum ProjectV2WorkflowsOrderField {
  /** The date and time of the workflow creation */
  CreatedAt = 'CREATED_AT',
  /** The name of the workflow */
  Name = 'NAME',
  /** The number of the workflow */
  Number = 'NUMBER',
  /** The date and time of the workflow update */
  UpdatedAt = 'UPDATED_AT',
}

/** A property that must match */
export type PropertyTargetDefinitionInput = {
  /** The name of the property */
  name: Scalars['String']['input'];
  /** The values to match for */
  propertyValues: Array<Scalars['String']['input']>;
  /** The source of the property. Choose 'custom' or 'system'. Defaults to 'custom' if not specified */
  source?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of PublishSponsorsTier */
export type PublishSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft tier to publish. */
  tierId: Scalars['ID']['input'];
};

/** The possible methods for updating a pull request's head branch with the base branch. */
export enum PullRequestBranchUpdateMethod {
  /** Update branch via merge */
  Merge = 'MERGE',
  /** Update branch via rebase */
  Rebase = 'REBASE',
}

/** Represents available types of methods to use when merging a pull request. */
export enum PullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = 'MERGE',
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = 'REBASE',
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = 'SQUASH',
}

/** Ways in which lists of issues can be ordered upon return. */
export type PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: OrderDirection;
  /** The field in which to order pull requests by. */
  field: PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export enum PullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order pull_requests by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
export type PullRequestParametersInput = {
  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */
  dismissStaleReviewsOnPush: Scalars['Boolean']['input'];
  /** Require an approving review in pull requests that modify files that have a designated code owner. */
  requireCodeOwnerReview: Scalars['Boolean']['input'];
  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */
  requireLastPushApproval: Scalars['Boolean']['input'];
  /** The number of approving reviews that are required before a pull request can be merged. */
  requiredApprovingReviewCount: Scalars['Int']['input'];
  /** All conversations on code must be resolved before a pull request can be merged. */
  requiredReviewThreadResolution: Scalars['Boolean']['input'];
};

/** The possible states of a pull request review comment. */
export enum PullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = 'PENDING',
  /** A comment that is part of a submitted review */
  Submitted = 'SUBMITTED',
}

/** The review status of a pull request. */
export enum PullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = 'APPROVED',
  /** Changes have been requested on the pull request. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** A review is required before the pull request can be merged. */
  ReviewRequired = 'REVIEW_REQUIRED',
}

/** The possible events to perform on a pull request review. */
export enum PullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = 'APPROVE',
  /** Submit general feedback without explicit approval. */
  Comment = 'COMMENT',
  /** Dismiss review so it now longer effects merging. */
  Dismiss = 'DISMISS',
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = 'REQUEST_CHANGES',
}

/** The possible states of a pull request review. */
export enum PullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = 'APPROVED',
  /** A review blocking the pull request from merging. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** An informational review. */
  Commented = 'COMMENTED',
  /** A review that has been dismissed. */
  Dismissed = 'DISMISSED',
  /** A review that has not yet been submitted. */
  Pending = 'PENDING',
}

/** The possible subject types of a pull request review comment. */
export enum PullRequestReviewThreadSubjectType {
  /** A comment that has been made against the file of a pull request */
  File = 'FILE',
  /** A comment that has been made against the line of a pull request */
  Line = 'LINE',
}

/** The possible states of a pull request. */
export enum PullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that has been closed by being merged. */
  Merged = 'MERGED',
  /** A pull request that is still open. */
  Open = 'OPEN',
}

/** The possible item types found in a timeline. */
export enum PullRequestTimelineItemsItemType {
  /** Represents an 'added_to_merge_queue' event on a given pull request. */
  AddedToMergeQueueEvent = 'ADDED_TO_MERGE_QUEUE_EVENT',
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = 'DEPLOYED_EVENT',
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = 'MERGED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = 'PULL_REQUEST_COMMIT',
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',
  /** A review object for a given pull request. */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_merge_queue' event on a given pull request. */
  RemovedFromMergeQueueEvent = 'REMOVED_FROM_MERGE_QUEUE_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT',
}

/** The possible target states when updating a pull request. */
export enum PullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that is still open. */
  Open = 'OPEN',
}

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum ReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = 'CONFUSED',
  /** Represents the `:eyes:` emoji. */
  Eyes = 'EYES',
  /** Represents the `:heart:` emoji. */
  Heart = 'HEART',
  /** Represents the `:hooray:` emoji. */
  Hooray = 'HOORAY',
  /** Represents the `:laugh:` emoji. */
  Laugh = 'LAUGH',
  /** Represents the `:rocket:` emoji. */
  Rocket = 'ROCKET',
  /** Represents the `:-1:` emoji. */
  ThumbsDown = 'THUMBS_DOWN',
  /** Represents the `:+1:` emoji. */
  ThumbsUp = 'THUMBS_UP',
}

/** Ways in which lists of reactions can be ordered upon return. */
export type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: OrderDirection;
  /** The field in which to order reactions by. */
  field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum ReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = 'CREATED_AT',
}

/** Parameters to be used for the ref_name condition */
export type RefNameConditionTargetInput = {
  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['input']>;
  /**
   * Array of ref names or patterns to include. One of these patterns must match
   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the
   * default branch or `~ALL` to include all branches.
   */
  include: Array<Scalars['String']['input']>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: OrderDirection;
  /** The field in which to order refs by. */
  field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum RefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = 'ALPHABETICAL',
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = 'TAG_COMMIT_DATE',
}

/** A ref update */
export type RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['GitObjectID']['input'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** Force a non fast-forward update. */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['GitRefname']['input'];
};

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RejectDeployments */
export type RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional comment for rejecting deployments */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']['input']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID']['input'];
};

/** Ways in which lists of releases can be ordered upon return. */
export type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: OrderDirection;
  /** The field in which to order releases by. */
  field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum ReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order releases alphabetically by name */
  Name = 'NAME',
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID']['input'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String']['input'];
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveEnterpriseMember */
export type RemoveEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the user should be removed. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the user to remove from the enterprise. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars['String']['input'];
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']['input']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID']['input'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveReaction */
export type RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the emoji reaction to remove. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveStar */
export type RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveUpvote */
export type RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of ReopenDiscussion */
export type ReopenDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the discussion to be reopened. */
  discussionId: Scalars['ID']['input'];
};

/** Autogenerated input type of ReopenIssue */
export type ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated input type of ReopenPullRequest */
export type ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated input type of ReorderEnvironment */
export type ReorderEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the environment to modify */
  environmentId: Scalars['ID']['input'];
  /** The desired position of the environment */
  position: Scalars['Int']['input'];
};

/** The privacy of a repository */
export enum RepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The privacy of a repository */
export enum RepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The privacy of a repository */
export enum RepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The merge options available for pull requests to this repository. */
export enum RepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = 'MERGE',
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = 'REBASE',
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = 'SQUASH',
}

/** The privacy of a repository */
export enum RepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The privacy of a repository */
export enum RepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The privacy of a repository */
export enum RepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The reasons a piece of content can be reported or minimized. */
export enum ReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = 'ABUSE',
  /** A duplicated piece of content */
  Duplicate = 'DUPLICATE',
  /** An irrelevant piece of content */
  OffTopic = 'OFF_TOPIC',
  /** An outdated piece of content */
  Outdated = 'OUTDATED',
  /** The content has been resolved */
  Resolved = 'RESOLVED',
  /** A spammy piece of content */
  Spam = 'SPAM',
}

/** The affiliation of a user to a repository */
export enum RepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = 'COLLABORATOR',
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = 'ORGANIZATION_MEMBER',
  /** Repositories that are owned by the authenticated user. */
  Owner = 'OWNER',
}

/** The reason a repository is listed as 'contributed'. */
export enum RepositoryContributionType {
  /** Created a commit */
  Commit = 'COMMIT',
  /** Created an issue */
  Issue = 'ISSUE',
  /** Created a pull request */
  PullRequest = 'PULL_REQUEST',
  /** Reviewed a pull request */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** Created the repository */
  Repository = 'REPOSITORY',
}

/** Parameters to be used for the repository_id condition */
export type RepositoryIdConditionTargetInput = {
  /** One of these repo IDs must match the repo. */
  repositoryIds: Array<Scalars['ID']['input']>;
};

/** A repository interaction limit. */
export enum RepositoryInteractionLimit {
  /** Users that are not collaborators will not be able to interact with the repository. */
  CollaboratorsOnly = 'COLLABORATORS_ONLY',
  /** Users that have not previously committed to a repository’s default branch will be unable to interact with the repository. */
  ContributorsOnly = 'CONTRIBUTORS_ONLY',
  /** Users that have recently created their account will be unable to interact with the repository. */
  ExistingUsers = 'EXISTING_USERS',
  /** No interaction limits are enabled. */
  NoLimit = 'NO_LIMIT',
}

/** The length for a repository interaction limit to be enabled for. */
export enum RepositoryInteractionLimitExpiry {
  /** The interaction limit will expire after 1 day. */
  OneDay = 'ONE_DAY',
  /** The interaction limit will expire after 1 month. */
  OneMonth = 'ONE_MONTH',
  /** The interaction limit will expire after 1 week. */
  OneWeek = 'ONE_WEEK',
  /** The interaction limit will expire after 6 months. */
  SixMonths = 'SIX_MONTHS',
  /** The interaction limit will expire after 3 days. */
  ThreeDays = 'THREE_DAYS',
}

/** Indicates where an interaction limit is configured. */
export enum RepositoryInteractionLimitOrigin {
  /** A limit that is configured at the organization level. */
  Organization = 'ORGANIZATION',
  /** A limit that is configured at the repository level. */
  Repository = 'REPOSITORY',
  /** A limit that is configured at the user-wide level. */
  User = 'USER',
}

/** Ordering options for repository invitation connections. */
export type RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repository invitations by. */
  field: RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export enum RepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = 'CREATED_AT',
}

/** The possible reasons a given repository could be in a locked state. */
export enum RepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = 'BILLING',
  /** The repository is locked due to a migration. */
  Migrating = 'MIGRATING',
  /** The repository is locked due to a move. */
  Moving = 'MOVING',
  /** The repository is locked due to a rename. */
  Rename = 'RENAME',
  /** The repository is locked due to a trade controls related reason. */
  TradeRestriction = 'TRADE_RESTRICTION',
  /** The repository is locked due to an ownership transfer. */
  TransferringOwnership = 'TRANSFERRING_OWNERSHIP',
}

/** Ordering options for repository migrations. */
export type RepositoryMigrationOrder = {
  /** The ordering direction. */
  direction: RepositoryMigrationOrderDirection;
  /** The field to order repository migrations by. */
  field: RepositoryMigrationOrderField;
};

/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */
export enum RepositoryMigrationOrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC',
}

/** Properties by which repository migrations can be ordered. */
export enum RepositoryMigrationOrderField {
  /** Order mannequins why when they were created. */
  CreatedAt = 'CREATED_AT',
}

/** Parameters to be used for the repository_name condition */
export type RepositoryNameConditionTargetInput = {
  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */
  exclude: Array<Scalars['String']['input']>;
  /**
   * Array of repository names or patterns to include. One of these patterns must
   * match for the condition to pass. Also accepts `~ALL` to include all repositories.
   */
  include: Array<Scalars['String']['input']>;
  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */
  protected?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Ordering options for repository connections */
export type RepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum RepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** The access level to a repository */
export enum RepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = 'ADMIN',
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = 'MAINTAIN',
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = 'READ',
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = 'TRIAGE',
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = 'WRITE',
}

/** The privacy of a repository */
export enum RepositoryPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC',
}

/** Parameters to be used for the repository_property condition */
export type RepositoryPropertyConditionTargetInput = {
  /** Array of repository properties that must not match. */
  exclude: Array<PropertyTargetDefinitionInput>;
  /** Array of repository properties that must match */
  include: Array<PropertyTargetDefinitionInput>;
};

/** Specifies the conditions required for a ruleset to evaluate */
export type RepositoryRuleConditionsInput = {
  /** Configuration for the ref_name condition */
  refName?: InputMaybe<RefNameConditionTargetInput>;
  /** Configuration for the repository_id condition */
  repositoryId?: InputMaybe<RepositoryIdConditionTargetInput>;
  /** Configuration for the repository_name condition */
  repositoryName?: InputMaybe<RepositoryNameConditionTargetInput>;
  /** Configuration for the repository_property condition */
  repositoryProperty?: InputMaybe<RepositoryPropertyConditionTargetInput>;
};

/** Specifies the attributes for a new or updated rule. */
export type RepositoryRuleInput = {
  /** Optional ID of this rule when updating */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The parameters for the rule. */
  parameters?: InputMaybe<RuleParametersInput>;
  /** The type of rule to create. */
  type: RepositoryRuleType;
};

/** Ordering options for repository rules. */
export type RepositoryRuleOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repository rules by. */
  field: RepositoryRuleOrderField;
};

/** Properties by which repository rule connections can be ordered. */
export enum RepositoryRuleOrderField {
  /** Order repository rules by created time */
  CreatedAt = 'CREATED_AT',
  /** Order repository rules by type */
  Type = 'TYPE',
  /** Order repository rules by updated time */
  UpdatedAt = 'UPDATED_AT',
}

/** The rule types supported in rulesets */
export enum RepositoryRuleType {
  /** Authorization */
  Authorization = 'AUTHORIZATION',
  /** Branch name pattern */
  BranchNamePattern = 'BRANCH_NAME_PATTERN',
  /**
   * Choose which tools must provide code scanning results before the reference is
   * updated. When configured, code scanning must be enabled and have results for
   * both the commit and the reference being updated.
   */
  CodeScanning = 'CODE_SCANNING',
  /** Committer email pattern */
  CommitterEmailPattern = 'COMMITTER_EMAIL_PATTERN',
  /** Commit author email pattern */
  CommitAuthorEmailPattern = 'COMMIT_AUTHOR_EMAIL_PATTERN',
  /** Commit message pattern */
  CommitMessagePattern = 'COMMIT_MESSAGE_PATTERN',
  /** Only allow users with bypass permission to create matching refs. */
  Creation = 'CREATION',
  /** Only allow users with bypass permissions to delete matching refs. */
  Deletion = 'DELETION',
  /**
   * Prevent commits that include files with specified file extensions from being
   * pushed to the commit graph. NOTE: Thie rule is in beta and subject to change
   */
  FileExtensionRestriction = 'FILE_EXTENSION_RESTRICTION',
  /**
   * Prevent commits that include changes in specified file paths from being pushed
   * to the commit graph. NOTE: Thie rule is in beta and subject to change
   */
  FilePathRestriction = 'FILE_PATH_RESTRICTION',
  /** Branch is read-only. Users cannot push to the branch. */
  LockBranch = 'LOCK_BRANCH',
  /**
   * Prevent commits that include file paths that exceed a specified character
   * limit from being pushed to the commit graph. NOTE: Thie rule is in beta and
   * subject to change
   */
  MaxFilePathLength = 'MAX_FILE_PATH_LENGTH',
  /**
   * Prevent commits that exceed a specified file size limit from being pushed to
   * the commit. NOTE: Thie rule is in beta and subject to change
   */
  MaxFileSize = 'MAX_FILE_SIZE',
  /** Max ref updates */
  MaxRefUpdates = 'MAX_REF_UPDATES',
  /** Merges must be performed via a merge queue. */
  MergeQueue = 'MERGE_QUEUE',
  /** Merge queue locked ref */
  MergeQueueLockedRef = 'MERGE_QUEUE_LOCKED_REF',
  /** Prevent users with push access from force pushing to refs. */
  NonFastForward = 'NON_FAST_FORWARD',
  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */
  PullRequest = 'PULL_REQUEST',
  /** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
  RequiredDeployments = 'REQUIRED_DEPLOYMENTS',
  /** Prevent merge commits from being pushed to matching refs. */
  RequiredLinearHistory = 'REQUIRED_LINEAR_HISTORY',
  /**
   * When enabled, all conversations on code must be resolved before a pull request
   * can be merged into a branch that matches this rule.
   */
  RequiredReviewThreadResolution = 'REQUIRED_REVIEW_THREAD_RESOLUTION',
  /** Commits pushed to matching refs must have verified signatures. */
  RequiredSignatures = 'REQUIRED_SIGNATURES',
  /**
   * Choose which status checks must pass before the ref is updated. When enabled,
   * commits must first be pushed to another ref where the checks pass.
   */
  RequiredStatusChecks = 'REQUIRED_STATUS_CHECKS',
  /**
   * Require all commits be made to a non-target branch and submitted via a pull
   * request and required workflow checks to pass before they can be merged.
   */
  RequiredWorkflowStatusChecks = 'REQUIRED_WORKFLOW_STATUS_CHECKS',
  /** Secret scanning */
  SecretScanning = 'SECRET_SCANNING',
  /** Tag */
  Tag = 'TAG',
  /** Tag name pattern */
  TagNamePattern = 'TAG_NAME_PATTERN',
  /** Only allow users with bypass permission to update matching refs. */
  Update = 'UPDATE',
  /** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
  Workflows = 'WORKFLOWS',
  /** Workflow files cannot be modified. */
  WorkflowUpdates = 'WORKFLOW_UPDATES',
}

/** The bypass mode for a specific actor on a ruleset. */
export enum RepositoryRulesetBypassActorBypassMode {
  /** The actor can always bypass rules */
  Always = 'ALWAYS',
  /** The actor can only bypass rules via a pull request */
  PullRequest = 'PULL_REQUEST',
}

/**
 * Specifies the attributes for a new or updated ruleset bypass actor. Only one of
 * `actor_id`, `repository_role_database_id`, `organization_admin`, or `deploy_key`
 * should be specified.
 */
export type RepositoryRulesetBypassActorInput = {
  /** For Team and Integration bypasses, the Team or Integration ID */
  actorId?: InputMaybe<Scalars['ID']['input']>;
  /** The bypass mode for this actor. */
  bypassMode: RepositoryRulesetBypassActorBypassMode;
  /** For deploy key bypasses, true. Can only use ALWAYS as the bypass mode */
  deployKey?: InputMaybe<Scalars['Boolean']['input']>;
  /** For organization owner bypasses, true */
  organizationAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** For role bypasses, the role database ID */
  repositoryRoleDatabaseId?: InputMaybe<Scalars['Int']['input']>;
};

/** The targets supported for rulesets. NOTE: The push target is in beta and subject to change. */
export enum RepositoryRulesetTarget {
  /** Branch */
  Branch = 'BRANCH',
  /** Push */
  Push = 'PUSH',
  /** Tag */
  Tag = 'TAG',
}

/** The repository's visibility level. */
export enum RepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
}

/** The possible scopes of an alert's dependency. */
export enum RepositoryVulnerabilityAlertDependencyScope {
  /** A dependency that is only used in development */
  Development = 'DEVELOPMENT',
  /** A dependency that is leveraged during application runtime */
  Runtime = 'RUNTIME',
}

/** The possible states of an alert */
export enum RepositoryVulnerabilityAlertState {
  /** An alert that has been automatically closed by Dependabot. */
  AutoDismissed = 'AUTO_DISMISSED',
  /** An alert that has been manually closed by a user. */
  Dismissed = 'DISMISSED',
  /** An alert that has been resolved by a code change. */
  Fixed = 'FIXED',
  /** An alert that is still open. */
  Open = 'OPEN',
}

/** Autogenerated input type of RequestReviews */
export type RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID']['input'];
  /** The Node IDs of the team to request. */
  teamIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Add users to the set rather than replace. */
  union?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node IDs of the user to request. */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The possible states that can be requested when creating a check run. */
export enum RequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING',
}

/** Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule. */
export type RequiredDeploymentsParametersInput = {
  /** The environments that must be successfully deployed to before branches can be merged. */
  requiredDeploymentEnvironments: Array<Scalars['String']['input']>;
};

/** Specifies the attributes for a new or updated required status check. */
export type RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  appId?: InputMaybe<Scalars['ID']['input']>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  context: Scalars['String']['input'];
};

/**
 * Choose which status checks must pass before the ref is updated. When enabled,
 * commits must first be pushed to another ref where the checks pass.
 */
export type RequiredStatusChecksParametersInput = {
  /** Status checks that are required. */
  requiredStatusChecks: Array<StatusCheckConfigurationInput>;
  /**
   * Whether pull requests targeting a matching branch must be tested with the
   * latest code. This setting will not take effect unless at least one status
   * check is enabled.
   */
  strictRequiredStatusChecksPolicy: Scalars['Boolean']['input'];
};

/** Autogenerated input type of RerequestCheckSuite */
export type RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of ResolveReviewThread */
export type ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID']['input'];
};

/** Autogenerated input type of RetireSponsorsTier */
export type RetireSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the published tier to retire. */
  tierId: Scalars['ID']['input'];
};

/** Autogenerated input type of RevertPullRequest */
export type RevertPullRequestInput = {
  /** The description of the revert pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the revert pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the pull request to revert. */
  pullRequestId: Scalars['ID']['input'];
  /** The title of the revert pull request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */
export type RevokeEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of the user to revoke the migrator role */
  login: Scalars['String']['input'];
};

/** Autogenerated input type of RevokeMigratorRole */
export type RevokeMigratorRoleInput = {
  /** The user login or Team slug to revoke the migrator role from. */
  actor: Scalars['String']['input'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID']['input'];
};

/** Possible roles a user may have in relation to an organization. */
export enum RoleInOrganization {
  /** A user who is a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** A user with full administrative access to the organization. */
  Owner = 'OWNER',
  /** A user who is unaffiliated with the organization. */
  Unaffiliated = 'UNAFFILIATED',
}

/** The level of enforcement for a rule or ruleset. */
export enum RuleEnforcement {
  /** Rules will be enforced */
  Active = 'ACTIVE',
  /** Do not evaluate or enforce rules */
  Disabled = 'DISABLED',
  /**
   * Allow admins to test rules before enforcing them. Admins can view insights on
   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
   */
  Evaluate = 'EVALUATE',
}

/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */
export type RuleParametersInput = {
  /** Parameters used for the `branch_name_pattern` rule type */
  branchNamePattern?: InputMaybe<BranchNamePatternParametersInput>;
  /** Parameters used for the `code_scanning` rule type */
  codeScanning?: InputMaybe<CodeScanningParametersInput>;
  /** Parameters used for the `commit_author_email_pattern` rule type */
  commitAuthorEmailPattern?: InputMaybe<CommitAuthorEmailPatternParametersInput>;
  /** Parameters used for the `commit_message_pattern` rule type */
  commitMessagePattern?: InputMaybe<CommitMessagePatternParametersInput>;
  /** Parameters used for the `committer_email_pattern` rule type */
  committerEmailPattern?: InputMaybe<CommitterEmailPatternParametersInput>;
  /** Parameters used for the `file_extension_restriction` rule type */
  fileExtensionRestriction?: InputMaybe<FileExtensionRestrictionParametersInput>;
  /** Parameters used for the `file_path_restriction` rule type */
  filePathRestriction?: InputMaybe<FilePathRestrictionParametersInput>;
  /** Parameters used for the `max_file_path_length` rule type */
  maxFilePathLength?: InputMaybe<MaxFilePathLengthParametersInput>;
  /** Parameters used for the `max_file_size` rule type */
  maxFileSize?: InputMaybe<MaxFileSizeParametersInput>;
  /** Parameters used for the `pull_request` rule type */
  pullRequest?: InputMaybe<PullRequestParametersInput>;
  /** Parameters used for the `required_deployments` rule type */
  requiredDeployments?: InputMaybe<RequiredDeploymentsParametersInput>;
  /** Parameters used for the `required_status_checks` rule type */
  requiredStatusChecks?: InputMaybe<RequiredStatusChecksParametersInput>;
  /** Parameters used for the `tag_name_pattern` rule type */
  tagNamePattern?: InputMaybe<TagNamePatternParametersInput>;
  /** Parameters used for the `update` rule type */
  update?: InputMaybe<UpdateParametersInput>;
  /** Parameters used for the `workflows` rule type */
  workflows?: InputMaybe<WorkflowsParametersInput>;
};

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export enum SamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = 'SHA1',
  /** SHA256 */
  Sha256 = 'SHA256',
  /** SHA384 */
  Sha384 = 'SHA384',
  /** SHA512 */
  Sha512 = 'SHA512',
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export enum SamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = 'RSA_SHA1',
  /** RSA-SHA256 */
  RsaSha256 = 'RSA_SHA256',
  /** RSA-SHA384 */
  RsaSha384 = 'RSA_SHA384',
  /** RSA-SHA512 */
  RsaSha512 = 'RSA_SHA512',
}

/** Ordering options for saved reply connections. */
export type SavedReplyOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order saved replies by. */
  field: SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export enum SavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = 'UPDATED_AT',
}

/** Represents the individual results of a search. */
export enum SearchType {
  /** Returns matching discussions in repositories. */
  Discussion = 'DISCUSSION',
  /** Returns results matching issues in repositories. */
  Issue = 'ISSUE',
  /** Returns results matching repositories. */
  Repository = 'REPOSITORY',
  /** Returns results matching users and organizations on GitHub. */
  User = 'USER',
}

/** Classification of the advisory. */
export enum SecurityAdvisoryClassification {
  /** Classification of general advisories. */
  General = 'GENERAL',
  /** Classification of malware advisories. */
  Malware = 'MALWARE',
}

/** The possible ecosystems of a security vulnerability's package. */
export enum SecurityAdvisoryEcosystem {
  /** GitHub Actions */
  Actions = 'ACTIONS',
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Erlang/Elixir packages hosted at hex.pm */
  Erlang = 'ERLANG',
  /** Go modules */
  Go = 'GO',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Dart packages hosted at pub.dev */
  Pub = 'PUB',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS',
  /** Rust crates */
  Rust = 'RUST',
  /** Swift packages */
  Swift = 'SWIFT',
}

/** An advisory identifier to filter results on. */
export type SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String']['input'];
};

/** Identifier formats available for advisories. */
export enum SecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = 'CVE',
  /** GitHub Security Advisory ID. */
  Ghsa = 'GHSA',
}

/** Ordering options for security advisory connections */
export type SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security advisories by. */
  field: SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export enum SecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = 'PUBLISHED_AT',
  /** Order advisories by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** Severity of the vulnerability. */
export enum SecurityAdvisorySeverity {
  /** Critical. */
  Critical = 'CRITICAL',
  /** High. */
  High = 'HIGH',
  /** Low. */
  Low = 'LOW',
  /** Moderate. */
  Moderate = 'MODERATE',
}

/** Ordering options for security vulnerability connections */
export type SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export enum SecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID']['input'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String']['input'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: InputMaybe<Scalars['String']['input']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['URI']['input'];
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of SetUserInteractionLimit */
export type SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars['ID']['input'];
};

/** Software or company that hosts social media accounts. */
export enum SocialAccountProvider {
  /** Social media and networking website. */
  Facebook = 'FACEBOOK',
  /** Catch-all for social media providers that do not yet have specific handling. */
  Generic = 'GENERIC',
  /** Fork of Mastodon with a greater focus on local posting. */
  Hometown = 'HOMETOWN',
  /** Social media website with a focus on photo and video sharing. */
  Instagram = 'INSTAGRAM',
  /** Professional networking website. */
  Linkedin = 'LINKEDIN',
  /** Open-source federated microblogging service. */
  Mastodon = 'MASTODON',
  /** JavaScript package registry. */
  Npm = 'NPM',
  /** Social news aggregation and discussion website. */
  Reddit = 'REDDIT',
  /** Live-streaming service. */
  Twitch = 'TWITCH',
  /** Microblogging website. */
  Twitter = 'TWITTER',
  /** Online video platform. */
  Youtube = 'YOUTUBE',
}

/** Ordering options for connections to get sponsor entities and associated USD amounts for GitHub Sponsors. */
export type SponsorAndLifetimeValueOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order results by. */
  field: SponsorAndLifetimeValueOrderField;
};

/** Properties by which sponsor and lifetime value connections can be ordered. */
export enum SponsorAndLifetimeValueOrderField {
  /** Order results by how much money the sponsor has paid in total. */
  LifetimeValue = 'LIFETIME_VALUE',
  /** Order results by the sponsor's login (username). */
  SponsorLogin = 'SPONSOR_LOGIN',
  /** Order results by the sponsor's relevance to the viewer. */
  SponsorRelevance = 'SPONSOR_RELEVANCE',
}

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type SponsorOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsor entities by. */
  field: SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export enum SponsorOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN',
  /** Order sponsors by their relevance to the viewer. */
  Relevance = 'RELEVANCE',
}

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type SponsorableOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorable entities by. */
  field: SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export enum SponsorableOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN',
}

/** The possible actions that GitHub Sponsors activities can represent. */
export enum SponsorsActivityAction {
  /** The activity was cancelling a sponsorship. */
  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',
  /** The activity was starting a sponsorship. */
  NewSponsorship = 'NEW_SPONSORSHIP',
  /** The activity was scheduling a downgrade or cancellation. */
  PendingChange = 'PENDING_CHANGE',
  /** The activity was funds being refunded to the sponsor or GitHub. */
  Refund = 'REFUND',
  /** The activity was disabling matching for a previously matched sponsorship. */
  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  TierChange = 'TIER_CHANGE',
}

/** Ordering options for GitHub Sponsors activity connections. */
export type SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order activity by. */
  field: SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export enum SponsorsActivityOrderField {
  /** Order activities by when they happened. */
  Timestamp = 'TIMESTAMP',
}

/** The possible time periods for which Sponsors activities can be requested. */
export enum SponsorsActivityPeriod {
  /** Don't restrict the activity to any date range, include all activity. */
  All = 'ALL',
  /** The previous calendar day. */
  Day = 'DAY',
  /** The previous thirty days. */
  Month = 'MONTH',
  /** The previous seven days. */
  Week = 'WEEK',
}

/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */
export enum SponsorsCountryOrRegionCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Åland */
  Ax = 'AX',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthélemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei Darussalam */
  Bn = 'BN',
  /** Bolivia */
  Bo = 'BO',
  /** Bonaire, Sint Eustatius and Saba */
  Bq = 'BQ',
  /** Brazil */
  Br = 'BR',
  /** Bahamas */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Bouvet Island */
  Bv = 'BV',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos (Keeling) Islands */
  Cc = 'CC',
  /** Congo (Kinshasa) */
  Cd = 'CD',
  /** Central African Republic */
  Cf = 'CF',
  /** Congo (Brazzaville) */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Côte d'Ivoire */
  Ci = 'CI',
  /** Cook Islands */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cape Verde */
  Cv = 'CV',
  /** Curaçao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czech Republic */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands */
  Fk = 'FK',
  /** Micronesia */
  Fm = 'FM',
  /** Faroe Islands */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** French Guiana */
  Gf = 'GF',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Guadeloupe */
  Gp = 'GP',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** South Georgia and South Sandwich Islands */
  Gs = 'GS',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Heard and McDonald Islands */
  Hm = 'HM',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** Korea, South */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Laos */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin (French part) */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands */
  Mh = 'MH',
  /** Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macau */
  Mo = 'MO',
  /** Northern Mariana Islands */
  Mp = 'MP',
  /** Martinique */
  Mq = 'MQ',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger */
  Ne = 'NE',
  /** Norfolk Island */
  Nf = 'NF',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Reunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russian Federation */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen Islands */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten (Dutch part) */
  Sx = 'SX',
  /** Swaziland */
  Sz = 'SZ',
  /** Turks and Caicos Islands */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** French Southern Lands */
  Tf = 'TF',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** Timor-Leste */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Türkiye */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan */
  Tw = 'TW',
  /** Tanzania */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States Minor Outlying Islands */
  Um = 'UM',
  /** United States of America */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Vatican City */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela */
  Ve = 'VE',
  /** Virgin Islands, British */
  Vg = 'VG',
  /** Virgin Islands, U.S. */
  Vi = 'VI',
  /** Vietnam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna Islands */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW',
}

/** The different kinds of goals a GitHub Sponsors member can have. */
export enum SponsorsGoalKind {
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',
  /** The goal is about reaching a certain number of sponsors. */
  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT',
}

/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */
export enum SponsorsListingFeaturedItemFeatureableType {
  /** A repository owned by the user or organization with the GitHub Sponsors profile. */
  Repository = 'REPOSITORY',
  /** A user who belongs to the organization with the GitHub Sponsors profile. */
  User = 'USER',
}

/** Ordering options for Sponsors tiers connections. */
export type SponsorsTierOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order tiers by. */
  field: SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export enum SponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS',
}

/** Ordering options for sponsorship newsletter connections. */
export type SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export enum SponsorshipNewsletterOrderField {
  /** Order sponsorship newsletters by when they were created. */
  CreatedAt = 'CREATED_AT',
}

/** Ordering options for sponsorship connections. */
export type SponsorshipOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order sponsorship by. */
  field: SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export enum SponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = 'CREATED_AT',
}

/** How payment was made for funding a GitHub Sponsors sponsorship. */
export enum SponsorshipPaymentSource {
  /** Payment was made through GitHub. */
  Github = 'GITHUB',
  /** Payment was made through Patreon. */
  Patreon = 'PATREON',
}

/** The privacy of a sponsorship */
export enum SponsorshipPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC',
}

/** The possible default commit messages for squash merges. */
export enum SquashMergeCommitMessage {
  /** Default to a blank commit message. */
  Blank = 'BLANK',
  /** Default to the branch's commit messages. */
  CommitMessages = 'COMMIT_MESSAGES',
  /** Default to the pull request's body. */
  PrBody = 'PR_BODY',
}

/** The possible default commit titles for squash merges. */
export enum SquashMergeCommitTitle {
  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */
  CommitOrPrTitle = 'COMMIT_OR_PR_TITLE',
  /** Default to the pull request's title. */
  PrTitle = 'PR_TITLE',
}

/** Ways in which star connections can be ordered. */
export type StarOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum StarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = 'STARRED_AT',
}

/** Autogenerated input type of StartOrganizationMigration */
export type StartOrganizationMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The migration source access token. */
  sourceAccessToken: Scalars['String']['input'];
  /** The URL of the organization to migrate. */
  sourceOrgUrl: Scalars['URI']['input'];
  /** The ID of the enterprise the target organization belongs to. */
  targetEnterpriseId: Scalars['ID']['input'];
  /** The name of the target organization. */
  targetOrgName: Scalars['String']['input'];
};

/** Autogenerated input type of StartRepositoryMigration */
export type StartRepositoryMigrationInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to continue the migration on error. Defaults to `true`. */
  continueOnError?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded git archive. */
  gitArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']['input']>;
  /** Whether to lock the source repository. */
  lockSource?: InputMaybe<Scalars['Boolean']['input']>;
  /** The signed URL to access the user-uploaded metadata archive. */
  metadataArchiveUrl?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization that will own the imported repository. */
  ownerId: Scalars['ID']['input'];
  /** The name of the imported repository. */
  repositoryName: Scalars['String']['input'];
  /** Whether to skip migrating releases for the repository. */
  skipReleases?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the migration source. */
  sourceId: Scalars['ID']['input'];
  /** The URL of the source repository. */
  sourceRepositoryUrl: Scalars['URI']['input'];
  /** The visibility of the imported repository. */
  targetRepoVisibility?: InputMaybe<Scalars['String']['input']>;
};

/** Required status check */
export type StatusCheckConfigurationInput = {
  /** The status check context name that must be present on the commit. */
  context: Scalars['String']['input'];
  /** The optional integration ID that this status check must originate from. */
  integrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** The possible commit status states. */
export enum StatusState {
  /** Status is errored. */
  Error = 'ERROR',
  /** Status is expected. */
  Expected = 'EXPECTED',
  /** Status is failing. */
  Failure = 'FAILURE',
  /** Status is pending. */
  Pending = 'PENDING',
  /** Status is successful. */
  Success = 'SUCCESS',
}

/** Autogenerated input type of SubmitPullRequestReview */
export type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The event to send to the Pull Request Review. */
  event: PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']['input']>;
};

/** The possible states of a subscription. */
export enum SubscriptionState {
  /** The User is never notified. */
  Ignored = 'IGNORED',
  /** The User is notified of all conversations. */
  Subscribed = 'SUBSCRIBED',
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = 'UNSUBSCRIBED',
}

/** Parameters to be used for the tag_name_pattern rule */
export type TagNamePatternParametersInput = {
  /** How this rule will appear to users. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If true, the rule will fail if the pattern matches. */
  negate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The operator to use for matching. */
  operator: Scalars['String']['input'];
  /** The pattern to match with. */
  pattern: Scalars['String']['input'];
};

/** Ways in which team discussion comment connections can be ordered. */
export type TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export enum TeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = 'NUMBER',
}

/** Ways in which team discussion connections can be ordered. */
export type TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field by which to order nodes. */
  field: TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export enum TeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = 'CREATED_AT',
}

/** Ordering options for team member connections */
export type TeamMemberOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order team members by. */
  field: TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export enum TeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order team members by login */
  Login = 'LOGIN',
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum TeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = 'MAINTAINER',
  /** A team member has no administrative permissions on the team. */
  Member = 'MEMBER',
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum TeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = 'ALL',
  /** Includes only child team members for the team. */
  ChildTeam = 'CHILD_TEAM',
  /** Includes only immediate members of the team. */
  Immediate = 'IMMEDIATE',
}

/** The possible team notification values. */
export enum TeamNotificationSetting {
  /** No one will receive notifications. */
  NotificationsDisabled = 'NOTIFICATIONS_DISABLED',
  /** Everyone will receive notifications when the team is @mentioned. */
  NotificationsEnabled = 'NOTIFICATIONS_ENABLED',
}

/** Ways in which team connections can be ordered. */
export type TeamOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum TeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = 'NAME',
}

/** The possible team privacy values. */
export enum TeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = 'SECRET',
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = 'VISIBLE',
}

/** Ordering options for team repository connections */
export type TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum TeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by permission */
  Permission = 'PERMISSION',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT',
}

/** The possible team review assignment algorithms */
export enum TeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = 'LOAD_BALANCE',
  /** Alternate reviews between each team member */
  RoundRobin = 'ROUND_ROBIN',
}

/** The role of a user on a team. */
export enum TeamRole {
  /** User has admin rights on the team. */
  Admin = 'ADMIN',
  /** User is a member of the team. */
  Member = 'MEMBER',
}

/** The possible states of a thread subscription form action */
export enum ThreadSubscriptionFormAction {
  /** The User cannot subscribe or unsubscribe to the thread */
  None = 'NONE',
  /** The User can subscribe to the thread */
  Subscribe = 'SUBSCRIBE',
  /** The User can unsubscribe to the thread */
  Unsubscribe = 'UNSUBSCRIBE',
}

/** The possible states of a subscription. */
export enum ThreadSubscriptionState {
  /** The subscription status is currently disabled. */
  Disabled = 'DISABLED',
  /** The User is never notified because they are ignoring the list */
  IgnoringList = 'IGNORING_LIST',
  /** The User is never notified because they are ignoring the thread */
  IgnoringThread = 'IGNORING_THREAD',
  /** The User is not recieving notifications from this thread */
  None = 'NONE',
  /** The User is notified becuase they are watching the list */
  SubscribedToList = 'SUBSCRIBED_TO_LIST',
  /** The User is notified because they are subscribed to the thread */
  SubscribedToThread = 'SUBSCRIBED_TO_THREAD',
  /** The User is notified because they chose custom settings for this thread. */
  SubscribedToThreadEvents = 'SUBSCRIBED_TO_THREAD_EVENTS',
  /** The User is notified because they chose custom settings for this thread. */
  SubscribedToThreadType = 'SUBSCRIBED_TO_THREAD_TYPE',
  /** The subscription status is currently unavailable. */
  Unavailable = 'UNAVAILABLE',
}

/** Reason that the suggested topic is declined. */
export enum TopicSuggestionDeclineReason {
  /**
   * The suggested topic is not relevant to the repository.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  NotRelevant = 'NOT_RELEVANT',
  /**
   * The viewer does not like the suggested topic.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  PersonalPreference = 'PERSONAL_PREFERENCE',
  /**
   * The suggested topic is too general for the repository.
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  TooGeneral = 'TOO_GENERAL',
  /**
   * The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1).
   * @deprecated Suggested topics are no longer supported Removal on 2024-04-01 UTC.
   */
  TooSpecific = 'TOO_SPECIFIC',
}

/** The possible states of a tracked issue. */
export enum TrackedIssueStates {
  /** The tracked issue is closed */
  Closed = 'CLOSED',
  /** The tracked issue is open */
  Open = 'OPEN',
}

/** Autogenerated input type of TransferEnterpriseOrganization */
export type TransferEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise where the organization should be transferred. */
  destinationEnterpriseId: Scalars['ID']['input'];
  /** The ID of the organization to transfer. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated input type of TransferIssue */
export type TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether to create labels if they don't exist in the target repository (matched by name) */
  createLabelsIfMissing?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID']['input'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnarchiveProjectV2Item */
export type UnarchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the ProjectV2Item to unarchive. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnarchiveRepository */
export type UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnfollowOrganization */
export type UnfollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the organization to unfollow. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnfollowUser */
export type UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnlinkProjectV2FromRepository */
export type UnlinkProjectV2FromRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the repository to unlink from the project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnlinkProjectV2FromTeam */
export type UnlinkProjectV2FromTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the project to unlink from the team. */
  projectId: Scalars['ID']['input'];
  /** The ID of the team to unlink from the project. */
  teamId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID']['input'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnlockLockable */
export type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The path of the file to mark as unviewed */
  path: Scalars['String']['input'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnmarkProjectV2AsTemplate */
export type UnmarkProjectV2AsTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Project to unmark as a template. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnminimizeComment */
export type UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnpinIssue */
export type UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnresolveReviewThread */
export type UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID']['input'];
};

/** Autogenerated input type of UnsubscribeFromNotifications */
export type UnsubscribeFromNotificationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The NotificationThread IDs of the objects to unsubscribe from. */
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']['input']>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID']['input'];
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Can admins override branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']['input']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: InputMaybe<Scalars['String']['input']>;
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']['input']>;
  /** The list of required deployment environments */
  requiredDeploymentEnvironments?: InputMaybe<
    Array<Scalars['String']['input']>
  >;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are successful deployments required before merging. */
  requiresDeployments?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Autogenerated input type of UpdateCheckRun */
export type UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['URI']['input']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** The name of the check. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Descriptive details about the run. */
  output?: InputMaybe<CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** The current status. */
  status?: InputMaybe<RequestableCheckStatusState>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateDiscussionComment */
export type UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateDiscussion */
export type UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars['ID']['input'];
  /** The new discussion title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String']['input'];
  /** The new role for the Enterprise administrator. */
  role: EnterpriseAdministratorRole;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the allow private repository forking policy on the enterprise. */
  policyValue?: InputMaybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID']['input'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: InputMaybe<
    Scalars['Boolean']['input']
  >;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']['input']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<
    Scalars['Boolean']['input']
  >;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */
export type UpdateEnterpriseOwnerOrganizationRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Enterprise which the owner belongs to. */
  enterpriseId: Scalars['ID']['input'];
  /** The ID of the organization for membership change. */
  organizationId: Scalars['ID']['input'];
  /** The role to assume in the organization. */
  organizationRole: RoleInOrganization;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The description of the enterprise. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID']['input'];
  /** The location of the enterprise. */
  location?: InputMaybe<Scalars['String']['input']>;
  /** The name of the enterprise. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID']['input'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: EnterpriseEnabledSettingValue;
};

/** Autogenerated input type of UpdateEnvironment */
export type UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The node ID of the environment. */
  environmentId: Scalars['ID']['input'];
  /** Whether deployments to this environment can be approved by the user who created the deployment. */
  preventSelfReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The wait timer in minutes. */
  waitTimer?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list enabled setting. */
  settingValue: IpAllowListEnabledSettingValue;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID']['input'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean']['input'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner. */
  ownerId: Scalars['ID']['input'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated input type of UpdateIssueComment */
export type UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID']['input'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The desired issue state. */
  state?: InputMaybe<IssueState>;
  /** The title for the issue. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateLabel */
export type UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: InputMaybe<Scalars['String']['input']>;
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID']['input'];
  /** The updated name of the label. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars['ID']['input'];
  /** The value for the restrict notifications setting. */
  settingValue: NotificationRestrictionSettingValue;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Enable forking of private repositories in the organization? */
  forkingEnabled: Scalars['Boolean']['input'];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  organizationId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */
export type UpdateOrganizationWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the organization on which to set the web commit signoff setting. */
  organizationId: Scalars['ID']['input'];
  /** Enable signoff on web-based commits for repositories in the organization? */
  webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Only allow users with bypass permission to update matching refs. */
export type UpdateParametersInput = {
  /** Branch can pull changes from its upstream repository */
  updateAllowsFetchAndMerge: Scalars['Boolean']['input'];
};

/** Autogenerated input type of UpdatePatreonSponsorability */
export type UpdatePatreonSponsorabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Whether Patreon tiers should be shown on the GitHub Sponsors profile page,
   * allowing potential sponsors to make their payment through Patreon instead of GitHub.
   */
  enablePatreonSponsorships: Scalars['Boolean']['input'];
  /**
   * The username of the organization with the GitHub Sponsors profile, if any.
   * Defaults to the GitHub Sponsors profile for the authenticated user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateProjectCard */
export type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  /** The note of ProjectCard. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateProjectColumn */
export type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project column. */
  name: Scalars['String']['input'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The name of project. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The Project ID to update. */
  projectId: Scalars['ID']['input'];
  /** Whether the project is public or not. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the project is open or closed. */
  state?: InputMaybe<ProjectState>;
};

/** Autogenerated input type of UpdateProjectV2Collaborators */
export type UpdateProjectV2CollaboratorsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The collaborators to update. */
  collaborators: Array<ProjectV2Collaborator>;
  /** The ID of the project to update the collaborators for. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateProjectV2DraftIssue */
export type UpdateProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the draft issue to update. */
  draftIssueId: Scalars['ID']['input'];
  /** The title of the draft issue. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateProjectV2 */
export type UpdateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Set the project to closed or open. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the Project to update. */
  projectId: Scalars['ID']['input'];
  /** Set the project to public or private. */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  /** Set the readme description of the project. */
  readme?: InputMaybe<Scalars['String']['input']>;
  /** Set the short description of the project. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  /** Set the title of the project. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateProjectV2ItemFieldValue */
export type UpdateProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the field to be updated. */
  fieldId: Scalars['ID']['input'];
  /** The ID of the item to be updated. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
  /** The value which will be set on the field. */
  value: ProjectV2FieldValue;
};

/** Autogenerated input type of UpdateProjectV2ItemPosition */
export type UpdateProjectV2ItemPositionInput = {
  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */
  afterId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the item to be moved. */
  itemId: Scalars['ID']['input'];
  /** The ID of the Project. */
  projectId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateProjectV2StatusUpdate */
export type UpdateProjectV2StatusUpdateInput = {
  /** The body of the status update. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The start date of the status update. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** The status of the status update. */
  status?: InputMaybe<ProjectV2StatusUpdateStatus>;
  /** The ID of the status update to be updated. */
  statusUpdateId: Scalars['ID']['input'];
  /** The target date of the status update. */
  targetDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
export type UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The head ref oid for the upstream branch. */
  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']['input']>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
  /** The update branch method to use. If omitted, defaults to 'MERGE' */
  updateMethod?: InputMaybe<PullRequestBranchUpdateMethod>;
};

/** Autogenerated input type of UpdatePullRequest */
export type UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: InputMaybe<Scalars['String']['input']>;
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']['input']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: InputMaybe<Scalars['ID']['input']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID']['input'];
  /** The target state of the pull request. */
  state?: InputMaybe<PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdatePullRequestReview */
export type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateRef */
export type UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['GitObjectID']['input'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateRefs */
export type UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A list of ref updates. */
  refUpdates: Array<RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateRepository */
export type UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Indicates if the repository should have the discussions feature enabled. */
  hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository displays a Sponsor button for financial contributions. */
  hasSponsorshipsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: InputMaybe<Scalars['URI']['input']>;
  /** The new name of the repository. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID']['input'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated input type of UpdateRepositoryRuleset */
export type UpdateRepositoryRulesetInput = {
  /** A list of actors that are allowed to bypass rules in this ruleset. */
  bypassActors?: InputMaybe<Array<RepositoryRulesetBypassActorInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The list of conditions for this ruleset */
  conditions?: InputMaybe<RepositoryRuleConditionsInput>;
  /** The enforcement level for this ruleset */
  enforcement?: InputMaybe<RuleEnforcement>;
  /** The name of the ruleset. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The global relay id of the repository ruleset to be updated. */
  repositoryRulesetId: Scalars['ID']['input'];
  /** The list of rules for this ruleset */
  rules?: InputMaybe<Array<RepositoryRuleInput>>;
  /** The target of the ruleset. */
  target?: InputMaybe<RepositoryRulesetTarget>;
};

/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */
export type UpdateRepositoryWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID']['input'];
  /** Indicates if the repository should require signoff on web-based commits. */
  webCommitSignoffRequired: Scalars['Boolean']['input'];
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']['input']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The new state of the subscription. */
  state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String']['input'];
  /** The current version of the body content. */
  bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: InputMaybe<Scalars['String']['input']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID']['input'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: InputMaybe<Scalars['Boolean']['input']>;
  /** The updated title of the discussion. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: InputMaybe<TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Count any members whose review has already been requested against the required number of members assigned to review */
  countMembersAlreadyRequested?: InputMaybe<Scalars['Boolean']['input']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean']['input'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars['ID']['input'];
  /** Include the members of any child teams when assigning */
  includeChildTeamMembers?: InputMaybe<Scalars['Boolean']['input']>;
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: InputMaybe<Scalars['Boolean']['input']>;
  /** Remove the team review request when assigning */
  removeTeamRequest?: InputMaybe<Scalars['Boolean']['input']>;
  /** The number of team members to assign */
  teamMemberCount?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateTeamsRepository */
export type UpdateTeamsRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Permission that should be granted to the teams. */
  permission: RepositoryPermission;
  /** Repository ID being granted access to. */
  repositoryId: Scalars['ID']['input'];
  /** A list of teams being granted access. Limit: 10 */
  teamIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated input type of UpdateTopics */
export type UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID']['input'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateUserList */
export type UpdateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A description of the list */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Whether or not the list is private */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the list to update. */
  listId: Scalars['ID']['input'];
  /** The name of the list */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateUserListsForItem */
export type UpdateUserListsForItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The item to add to the list */
  itemId: Scalars['ID']['input'];
  /** The lists to which this item should belong */
  listIds: Array<Scalars['ID']['input']>;
  /** The suggested lists to create and add this item to */
  suggestedListIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** The possible durations that a user can be blocked for. */
export enum UserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = 'ONE_DAY',
  /** The user was blocked for 30 days */
  OneMonth = 'ONE_MONTH',
  /** The user was blocked for 7 days */
  OneWeek = 'ONE_WEEK',
  /** The user was blocked permanently */
  Permanent = 'PERMANENT',
  /** The user was blocked for 3 days */
  ThreeDays = 'THREE_DAYS',
}

/** Ordering options for user status connections. */
export type UserStatusOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order user statuses by. */
  field: UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export enum UserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = 'UPDATED_AT',
}

/** Ordering options for verifiable domain connections. */
export type VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order verifiable domains by. */
  field: VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export enum VerifiableDomainOrderField {
  /** Order verifiable domains by their creation date. */
  CreatedAt = 'CREATED_AT',
  /** Order verifiable domains by the domain name. */
  Domain = 'DOMAIN',
}

/** Autogenerated input type of VerifyVerifiableDomain */
export type VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars['ID']['input'];
};

/** A workflow that must run for this rule to pass */
export type WorkflowFileReferenceInput = {
  /** The path to the workflow file */
  path: Scalars['String']['input'];
  /** The ref (branch or tag) of the workflow file to use */
  ref?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the repository where the workflow is defined */
  repositoryId: Scalars['Int']['input'];
  /** The commit SHA of the workflow file to use */
  sha?: InputMaybe<Scalars['String']['input']>;
};

/** Ways in which lists of workflow runs can be ordered upon return. */
export type WorkflowRunOrder = {
  /** The direction in which to order workflow runs by the specified field. */
  direction: OrderDirection;
  /** The field by which to order workflows. */
  field: WorkflowRunOrderField;
};

/** Properties by which workflow run connections can be ordered. */
export enum WorkflowRunOrderField {
  /** Order workflow runs by most recently created */
  CreatedAt = 'CREATED_AT',
}

/** The possible states for a workflow. */
export enum WorkflowState {
  /** The workflow is active. */
  Active = 'ACTIVE',
  /** The workflow was deleted from the git repository. */
  Deleted = 'DELETED',
  /** The workflow was disabled by default on a fork. */
  DisabledFork = 'DISABLED_FORK',
  /** The workflow was disabled for inactivity in the repository. */
  DisabledInactivity = 'DISABLED_INACTIVITY',
  /** The workflow was disabled manually. */
  DisabledManually = 'DISABLED_MANUALLY',
}

/** Require all changes made to a targeted branch to pass the specified workflows before they can be merged. */
export type WorkflowsParametersInput = {
  /** Workflows that must pass for this rule to pass. */
  workflows: Array<WorkflowFileReferenceInput>;
};

type AssigneeFields_Bot_Fragment = {
  login: string;
  html_url: string;
  type: 'Bot';
};

type AssigneeFields_Mannequin_Fragment = {
  login: string;
  html_url: string;
  type: 'Mannequin';
};

type AssigneeFields_Organization_Fragment = {
  login: string;
  name?: string | null;
  html_url: string;
  type: 'Organization';
};

type AssigneeFields_User_Fragment = {
  login: string;
  name?: string | null;
  html_url: string;
  type: 'User';
};

export type AssigneeFieldsFragment =
  | AssigneeFields_Bot_Fragment
  | AssigneeFields_Mannequin_Fragment
  | AssigneeFields_Organization_Fragment
  | AssigneeFields_User_Fragment;

export type CommitFieldsFragment = {
  oid: string;
  message: string;
  url: string;
  authoredDate: string;
  changedFilesIfAvailable?: number | null;
  changedFiles: number;
  additions: number;
  deletions: number;
  author?: {
    name?: string | null;
    email?: string | null;
    user?: {login: string; url: string; type: 'User'} | null;
  } | null;
  committer?: {date?: string | null} | null;
};

export type CommitsQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  branch: Scalars['String']['input'];
  since?: InputMaybe<Scalars['GitTimestamp']['input']>;
  until?: InputMaybe<Scalars['GitTimestamp']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;

export type CommitsQuery = {
  repository?: {
    ref?: {
      target?:
        | {type: 'Blob'}
        | {
            type: 'Commit';
            history: {
              pageInfo: {endCursor?: string | null; hasNextPage: boolean};
              nodes?: Array<{
                oid: string;
                message: string;
                url: string;
                authoredDate: string;
                changedFilesIfAvailable?: number | null;
                changedFiles: number;
                additions: number;
                deletions: number;
                author?: {
                  name?: string | null;
                  email?: string | null;
                  user?: {login: string; url: string; type: 'User'} | null;
                } | null;
                committer?: {date?: string | null} | null;
              } | null> | null;
            };
          }
        | {type: 'Tag'}
        | {type: 'Tree'}
        | null;
    } | null;
  } | null;
};

export type FilesFragment = {
  files?: {
    pageInfo: {hasNextPage: boolean; endCursor?: string | null};
    nodes?: Array<{
      path: string;
      additions: number;
      deletions: number;
    } | null> | null;
  } | null;
};

export type IssuesQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  page_size?: InputMaybe<Scalars['Int']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;

export type IssuesQuery = {
  repository?: {
    issues: {
      pageInfo: {endCursor?: string | null; hasNextPage: boolean};
      nodes?: Array<{
        databaseId?: number | null;
        title: string;
        bodyText: string;
        state: IssueState;
        createdAt: string;
        updatedAt: string;
        closedAt?: string | null;
        author?:
          | {login: string; html_url: string; type: 'Bot'}
          | {
              name?: string | null;
              login: string;
              html_url: string;
              type: 'EnterpriseUserAccount';
            }
          | {login: string; html_url: string; type: 'Mannequin'}
          | {
              name?: string | null;
              login: string;
              html_url: string;
              type: 'Organization';
            }
          | {
              name?: string | null;
              login: string;
              html_url: string;
              type: 'User';
            }
          | null;
        labels?: {nodes?: Array<{name: string} | null> | null} | null;
        assignments: {
          nodes?: Array<
            | {type: 'AddedToProjectEvent'}
            | {
                createdAt: string;
                type: 'AssignedEvent';
                assignee?:
                  | {login: string; html_url: string; type: 'Bot'}
                  | {login: string; html_url: string; type: 'Mannequin'}
                  | {
                      login: string;
                      name?: string | null;
                      html_url: string;
                      type: 'Organization';
                    }
                  | {
                      login: string;
                      name?: string | null;
                      html_url: string;
                      type: 'User';
                    }
                  | null;
              }
            | {type: 'ClosedEvent'}
            | {type: 'CommentDeletedEvent'}
            | {type: 'ConnectedEvent'}
            | {type: 'ConvertedNoteToIssueEvent'}
            | {type: 'ConvertedToDiscussionEvent'}
            | {type: 'CrossReferencedEvent'}
            | {type: 'DemilestonedEvent'}
            | {type: 'DisconnectedEvent'}
            | {type: 'IssueComment'}
            | {type: 'LabeledEvent'}
            | {type: 'LockedEvent'}
            | {type: 'MarkedAsDuplicateEvent'}
            | {type: 'MentionedEvent'}
            | {type: 'MilestonedEvent'}
            | {type: 'MovedColumnsInProjectEvent'}
            | {type: 'PinnedEvent'}
            | {type: 'ReferencedEvent'}
            | {type: 'RemovedFromProjectEvent'}
            | {type: 'RenamedTitleEvent'}
            | {type: 'ReopenedEvent'}
            | {type: 'SubscribedEvent'}
            | {type: 'TransferredEvent'}
            | {
                createdAt: string;
                type: 'UnassignedEvent';
                assignee?:
                  | {login: string; html_url: string; type: 'Bot'}
                  | {login: string; html_url: string; type: 'Mannequin'}
                  | {
                      login: string;
                      name?: string | null;
                      html_url: string;
                      type: 'Organization';
                    }
                  | {
                      login: string;
                      name?: string | null;
                      html_url: string;
                      type: 'User';
                    }
                  | null;
              }
            | {type: 'UnlabeledEvent'}
            | {type: 'UnlockedEvent'}
            | {type: 'UnmarkedAsDuplicateEvent'}
            | {type: 'UnpinnedEvent'}
            | {type: 'UnsubscribedEvent'}
            | {type: 'UserBlockedEvent'}
            | null
          > | null;
        };
      } | null> | null;
    };
  } | null;
};

export type LabelsFragment = {
  labels?: {
    pageInfo: {hasNextPage: boolean; endCursor?: string | null};
    nodes?: Array<{name: string} | null> | null;
  } | null;
};

export type LabelsQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type LabelsQuery = {
  repository?: {
    labels?: {
      nodes?: Array<{name: string} | null> | null;
      pageInfo: {endCursor?: string | null; hasNextPage: boolean};
    } | null;
  } | null;
};

export type ListMembersQueryVariables = Exact<{
  login: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type ListMembersQuery = {
  organization?: {
    membersWithRole: {
      nodes?: Array<{
        login: string;
        name?: string | null;
        email: string;
        html_url: string;
        type: 'User';
      } | null> | null;
      pageInfo: {endCursor?: string | null; hasNextPage: boolean};
    };
  } | null;
};

export type ListSamlSsoUsersQueryVariables = Exact<{
  login: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type ListSamlSsoUsersQuery = {
  organization?: {
    samlIdentityProvider?: {
      externalIdentities: {
        nodes?: Array<{
          samlIdentity?: {nameId?: string | null} | null;
          user?: {login: string; html_url: string; type: 'User'} | null;
        } | null> | null;
        pageInfo: {endCursor?: string | null; hasNextPage: boolean};
      };
    } | null;
  } | null;
};

export type ProjectsQueryVariables = Exact<{
  login: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type ProjectsQuery = {
  organization?: {
    projectsV2: {
      nodes?: Array<{
        id: string;
        name: string;
        body?: string | null;
        created_at: string;
        updated_at: string;
      } | null> | null;
      pageInfo: {hasNextPage: boolean; endCursor?: string | null};
    };
  } | null;
};

export type PullRequestReviewRequestsQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  nested_page_size: Scalars['Int']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;

export type PullRequestReviewRequestsQuery = {
  repository?: {
    pullRequest?: {
      reviewRequests?: {
        pageInfo: {hasNextPage: boolean; endCursor?: string | null};
        nodes?: Array<{
          requestedReviewer?:
            | {type: 'Bot'}
            | {login: string; html_url: string; type: 'Mannequin'}
            | {
                type: 'Team';
                members: {
                  nodes?: Array<{
                    login: string;
                    name?: string | null;
                    type: 'User';
                    html_url: string;
                  } | null> | null;
                };
              }
            | {
                login: string;
                name?: string | null;
                html_url: string;
                type: 'User';
              }
            | null;
        } | null> | null;
      } | null;
    } | null;
  } | null;
};

export type PullRequestReviewsQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  nested_page_size: Scalars['Int']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;

export type PullRequestReviewsQuery = {
  repository?: {
    pullRequest?: {
      reviews?: {
        pageInfo: {hasNextPage: boolean; endCursor?: string | null};
        nodes?: Array<{
          state: PullRequestReviewState;
          submittedAt?: string | null;
          databaseId?: number | null;
          url: string;
          author?:
            | {login: string; html_url: string; type: 'Bot'}
            | {
                name?: string | null;
                login: string;
                html_url: string;
                type: 'EnterpriseUserAccount';
              }
            | {login: string; html_url: string; type: 'Mannequin'}
            | {
                name?: string | null;
                login: string;
                html_url: string;
                type: 'Organization';
              }
            | {
                name?: string | null;
                login: string;
                html_url: string;
                type: 'User';
              }
            | null;
          comments: {totalCount: number};
        } | null> | null;
      } | null;
    } | null;
  } | null;
};

export type PullRequestsCursorQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type PullRequestsCursorQuery = {
  repository?: {
    pullRequests: {
      pageInfo: {
        startCursor?: string | null;
        endCursor?: string | null;
        hasNextPage: boolean;
      };
      nodes?: Array<{updatedAt: string} | null> | null;
    };
  } | null;
};

export type PullRequestsQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
  nested_page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type PullRequestsQuery = {
  repository?: {
    pullRequests: {
      pageInfo: {endCursor?: string | null; hasNextPage: boolean};
      nodes?: Array<{
        additions: number;
        body: string;
        changedFiles: number;
        createdAt: string;
        deletions: number;
        isDraft: boolean;
        number: number;
        mergedAt?: string | null;
        state: PullRequestState;
        title: string;
        updatedAt: string;
        url: string;
        baseRefName: string;
        headRefName: string;
        author?:
          | {login: string; html_url: string; type: 'Bot'}
          | {
              name?: string | null;
              login: string;
              html_url: string;
              type: 'EnterpriseUserAccount';
            }
          | {login: string; html_url: string; type: 'Mannequin'}
          | {
              name?: string | null;
              login: string;
              html_url: string;
              type: 'Organization';
            }
          | {
              name?: string | null;
              login: string;
              html_url: string;
              type: 'User';
            }
          | null;
        commits: {
          totalCount: number;
          nodes?: Array<{commit: {oid: string}} | null> | null;
        };
        comments: {totalCount: number};
        mergeCommit?: {oid: string} | null;
        reviewEvents: {
          nodes?: Array<
            | {type: 'AddedToMergeQueueEvent'}
            | {type: 'AddedToProjectEvent'}
            | {type: 'AssignedEvent'}
            | {type: 'AutoMergeDisabledEvent'}
            | {type: 'AutoMergeEnabledEvent'}
            | {type: 'AutoRebaseEnabledEvent'}
            | {type: 'AutoSquashEnabledEvent'}
            | {type: 'AutomaticBaseChangeFailedEvent'}
            | {type: 'AutomaticBaseChangeSucceededEvent'}
            | {type: 'BaseRefChangedEvent'}
            | {type: 'BaseRefDeletedEvent'}
            | {type: 'BaseRefForcePushedEvent'}
            | {type: 'ClosedEvent'}
            | {type: 'CommentDeletedEvent'}
            | {type: 'ConnectedEvent'}
            | {createdAt: string; type: 'ConvertToDraftEvent'}
            | {type: 'ConvertedNoteToIssueEvent'}
            | {type: 'ConvertedToDiscussionEvent'}
            | {type: 'CrossReferencedEvent'}
            | {type: 'DemilestonedEvent'}
            | {type: 'DeployedEvent'}
            | {type: 'DeploymentEnvironmentChangedEvent'}
            | {type: 'DisconnectedEvent'}
            | {type: 'HeadRefDeletedEvent'}
            | {type: 'HeadRefForcePushedEvent'}
            | {type: 'HeadRefRestoredEvent'}
            | {type: 'IssueComment'}
            | {type: 'LabeledEvent'}
            | {type: 'LockedEvent'}
            | {type: 'MarkedAsDuplicateEvent'}
            | {type: 'MentionedEvent'}
            | {type: 'MergedEvent'}
            | {type: 'MilestonedEvent'}
            | {type: 'MovedColumnsInProjectEvent'}
            | {type: 'PinnedEvent'}
            | {type: 'PullRequestCommit'}
            | {type: 'PullRequestCommitCommentThread'}
            | {type: 'PullRequestReview'}
            | {type: 'PullRequestReviewThread'}
            | {type: 'PullRequestRevisionMarker'}
            | {createdAt: string; type: 'ReadyForReviewEvent'}
            | {type: 'ReferencedEvent'}
            | {type: 'RemovedFromMergeQueueEvent'}
            | {type: 'RemovedFromProjectEvent'}
            | {type: 'RenamedTitleEvent'}
            | {type: 'ReopenedEvent'}
            | {type: 'ReviewDismissedEvent'}
            | {type: 'ReviewRequestRemovedEvent'}
            | {type: 'ReviewRequestedEvent'}
            | {type: 'SubscribedEvent'}
            | {type: 'TransferredEvent'}
            | {type: 'UnassignedEvent'}
            | {type: 'UnlabeledEvent'}
            | {type: 'UnlockedEvent'}
            | {type: 'UnmarkedAsDuplicateEvent'}
            | {type: 'UnpinnedEvent'}
            | {type: 'UnsubscribedEvent'}
            | {type: 'UserBlockedEvent'}
            | null
          > | null;
        };
        baseRepository?: {
          name: string;
          owner: {login: string} | {login: string};
        } | null;
        headRepository?: {
          name: string;
          owner: {login: string} | {login: string};
        } | null;
        labels?: {
          pageInfo: {hasNextPage: boolean; endCursor?: string | null};
          nodes?: Array<{name: string} | null> | null;
        } | null;
        files?: {
          pageInfo: {hasNextPage: boolean; endCursor?: string | null};
          nodes?: Array<{
            path: string;
            additions: number;
            deletions: number;
          } | null> | null;
        } | null;
        reviews?: {
          pageInfo: {hasNextPage: boolean; endCursor?: string | null};
          nodes?: Array<{
            state: PullRequestReviewState;
            submittedAt?: string | null;
            databaseId?: number | null;
            url: string;
            author?:
              | {login: string; html_url: string; type: 'Bot'}
              | {
                  name?: string | null;
                  login: string;
                  html_url: string;
                  type: 'EnterpriseUserAccount';
                }
              | {login: string; html_url: string; type: 'Mannequin'}
              | {
                  name?: string | null;
                  login: string;
                  html_url: string;
                  type: 'Organization';
                }
              | {
                  name?: string | null;
                  login: string;
                  html_url: string;
                  type: 'User';
                }
              | null;
            comments: {totalCount: number};
          } | null> | null;
        } | null;
        reviewRequests?: {
          pageInfo: {hasNextPage: boolean; endCursor?: string | null};
          nodes?: Array<{
            requestedReviewer?:
              | {type: 'Bot'}
              | {login: string; html_url: string; type: 'Mannequin'}
              | {
                  type: 'Team';
                  members: {
                    nodes?: Array<{
                      login: string;
                      name?: string | null;
                      type: 'User';
                      html_url: string;
                    } | null> | null;
                  };
                }
              | {
                  login: string;
                  name?: string | null;
                  html_url: string;
                  type: 'User';
                }
              | null;
          } | null> | null;
        } | null;
      } | null> | null;
    };
  } | null;
};

export type RepoTagsQueryVariables = Exact<{
  owner: Scalars['String']['input'];
  repo: Scalars['String']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
  page_size?: InputMaybe<Scalars['Int']['input']>;
}>;

export type RepoTagsQuery = {
  repository?: {
    refs?: {
      nodes?: Array<{
        name: string;
        target?:
          | {type: 'Blob'}
          | {committedDate: string; sha: string; type: 'Commit'}
          | {
              type: 'Tag';
              target:
                | {type: 'Blob'}
                | {committedDate: string; sha: string; type: 'Commit'}
                | {type: 'Tag'}
                | {type: 'Tree'};
            }
          | {type: 'Tree'}
          | null;
      } | null> | null;
      pageInfo: {hasNextPage: boolean; endCursor?: string | null};
    } | null;
  } | null;
};

export type ReviewFieldsFragment = {
  state: PullRequestReviewState;
  submittedAt?: string | null;
  databaseId?: number | null;
  url: string;
  author?:
    | {login: string; html_url: string; type: 'Bot'}
    | {
        name?: string | null;
        login: string;
        html_url: string;
        type: 'EnterpriseUserAccount';
      }
    | {login: string; html_url: string; type: 'Mannequin'}
    | {
        name?: string | null;
        login: string;
        html_url: string;
        type: 'Organization';
      }
    | {name?: string | null; login: string; html_url: string; type: 'User'}
    | null;
  comments: {totalCount: number};
};

export type ReviewRequestFieldsFragment = {
  requestedReviewer?:
    | {type: 'Bot'}
    | {login: string; html_url: string; type: 'Mannequin'}
    | {
        type: 'Team';
        members: {
          nodes?: Array<{
            login: string;
            name?: string | null;
            type: 'User';
            html_url: string;
          } | null> | null;
        };
      }
    | {login: string; name?: string | null; html_url: string; type: 'User'}
    | null;
};

export type ReviewRequestsFragment = {
  reviewRequests?: {
    pageInfo: {hasNextPage: boolean; endCursor?: string | null};
    nodes?: Array<{
      requestedReviewer?:
        | {type: 'Bot'}
        | {login: string; html_url: string; type: 'Mannequin'}
        | {
            type: 'Team';
            members: {
              nodes?: Array<{
                login: string;
                name?: string | null;
                type: 'User';
                html_url: string;
              } | null> | null;
            };
          }
        | {login: string; name?: string | null; html_url: string; type: 'User'}
        | null;
    } | null> | null;
  } | null;
};

export type ReviewsFragment = {
  reviews?: {
    pageInfo: {hasNextPage: boolean; endCursor?: string | null};
    nodes?: Array<{
      state: PullRequestReviewState;
      submittedAt?: string | null;
      databaseId?: number | null;
      url: string;
      author?:
        | {login: string; html_url: string; type: 'Bot'}
        | {
            name?: string | null;
            login: string;
            html_url: string;
            type: 'EnterpriseUserAccount';
          }
        | {login: string; html_url: string; type: 'Mannequin'}
        | {
            name?: string | null;
            login: string;
            html_url: string;
            type: 'Organization';
          }
        | {name?: string | null; login: string; html_url: string; type: 'User'}
        | null;
      comments: {totalCount: number};
    } | null> | null;
  } | null;
};
