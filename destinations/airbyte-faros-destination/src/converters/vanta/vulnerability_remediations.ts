import {AirbyteRecord} from 'faros-airbyte-cdk';
import {VulnerabilityRemediation} from 'faros-airbyte-common/vanta';
import {Utils} from 'faros-js-client';

import {ArtifactKey} from '../common/cicd';
import {RepoKey} from '../common/vcs';
import {DestinationModel, DestinationRecord, StreamContext} from '../converter';
import {VantaConverter} from './common';
import {getQueryFromName} from './utils';

export abstract class VulnerabilityRemediations extends VantaConverter {
  readonly destinationModels: ReadonlyArray<DestinationModel> = [];
  readonly vulnerabilitiesWithoutAsset = new Set<string>();
  readonly vulnerabilitiesWithoutSupportedAsset = new Set<string>();

  private readonly vcsRepositoryVulnerabilityQuery = getQueryFromName(
    'vcsRepositoryVulnerabilityQuery'
  );
  private readonly cicdArtifactVulnerabilityQuery = getQueryFromName(
    'cicdArtifactVulnerabilityQuery'
  );

  async convert(
    record: AirbyteRecord,
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    const vulnerabilityRemediation = record?.record
      ?.data as VulnerabilityRemediation;
    // We create sec_Vulnerability per finding, not per unique vulnerability.
    // So sec_Vulnerability will be tied either to one vcs_RepositoryVulnerability or cicd_ArtifactVulnerability.
    // If the remediation is not tied to any asset, we skip it.
    if (!vulnerabilityRemediation.asset) {
      this.vulnerabilitiesWithoutAsset.add(vulnerabilityRemediation.id);
      return [];
    }
    if (this.isVCSRepoVulnerability(vulnerabilityRemediation.asset)) {
      const repoKeys: RepoKey[] = await this.getRepoKeysFromVulnerability(
        vulnerabilityRemediation,
        ctx
      );
      // For each repo key, we create a vcs_RepositoryVulnerability__Update record:
      const records: DestinationRecord[] = [];
      for (const repoKey of repoKeys) {
        if (repoKey === null) {
          continue;
        }
        records.push({
          model: 'vcs_RepositoryVulnerability__Update',
          record: {
            where: {
              vulnerability: {
                uid: vulnerabilityRemediation.vulnerabilityId,
                source: this.source,
              },
              repository: repoKey,
            },
            mask: ['resolvedAt'],
            patch: {
              resolvedAt: Utils.toDate(
                vulnerabilityRemediation.remediationDate
              ),
            },
          },
        });
      }
      return records;
    } else if (
      this.isCICDArtifactVulnerability(vulnerabilityRemediation.asset)
    ) {
      const artifactKeys: ArtifactKey[] =
        await this.getArtifactKeysFromVulnerability(
          vulnerabilityRemediation,
          ctx
        );
      const records: DestinationRecord[] = [];
      for (const artifactKey of artifactKeys) {
        if (artifactKey === null) {
          continue;
        }
        records.push({
          model: 'cicd_ArtifactVulnerability__Update',
          record: {
            where: {
              vulnerability: {
                uid: vulnerabilityRemediation.vulnerabilityId,
                source: this.source,
              },
              artifact: artifactKey,
            },
            mask: ['resolvedAt'],
            patch: {
              resolvedAt: Utils.toDate(
                vulnerabilityRemediation.remediationDate
              ),
            },
          },
        });
      }
      return records;
    }
    this.vulnerabilitiesWithoutSupportedAsset.add(vulnerabilityRemediation.id);
    return [];
  }

  async onProcessingComplete(
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    this.logVulnerabilityWarnings(
      ctx,
      this.vulnerabilitiesWithoutAsset,
      'Vulnerability remediations without an asset associated found'
    );
    this.logVulnerabilityWarnings(
      ctx,
      this.vulnerabilitiesWithoutSupportedAsset,
      'Vulnerability remediations with no supported vulnerable asset found'
    );
    return [];
  }

  protected async getRepoKeysFromVulnerability(
    vulnerabilityRemediation: VulnerabilityRemediation,
    ctx: StreamContext
  ): Promise<RepoKey[]> {
    const result = await ctx.farosClient.gql(
      ctx.graph,
      this.vcsRepositoryVulnerabilityQuery,
      {
        vulnerabilityIds: [vulnerabilityRemediation.vulnerabilityId],
      }
    );
    return (
      result?.vcs_RepositoryVulnerability
        ?.filter(
          (item: any) =>
            // Filter out items with null/undefined required fields
            item?.repository?.name &&
            item?.repository?.organization?.uid &&
            item?.repository?.organization?.source
        )
        .map((item: any) => ({
          name: item.repository.name,
          organization: {
            uid: item.repository.organization.uid,
            source: item.repository.organization.source,
          },
        })) || []
    );
  }

  protected async getArtifactKeysFromVulnerability(
    vulnerabilityRemediation: VulnerabilityRemediation,
    ctx: StreamContext
  ): Promise<ArtifactKey[]> {
    const result = await ctx.farosClient.gql(
      ctx.graph,
      this.cicdArtifactVulnerabilityQuery,
      {
        vulnerabilityIds: [vulnerabilityRemediation.vulnerabilityId],
      }
    );
    ctx.logger.info(`Result: ${JSON.stringify(result)}`);
    return (
      result?.cicd_ArtifactVulnerability
        ?.filter(
          (item: any) =>
            // Filter out items with null/undefined required fields
            item?.artifact?.uid &&
            item?.artifact?.repository?.uid &&
            item?.artifact?.repository?.organization?.uid &&
            item?.artifact?.repository?.organization?.source
        )
        .map((item: any) => ({
          uid: item.artifact.uid,
          repository: {
            uid: item.artifact.repository.uid,
            organization: {
              uid: item.artifact.repository.organization.uid,
              source: item.artifact.repository.organization.source,
            },
          },
        })) || []
    );
  }
}
