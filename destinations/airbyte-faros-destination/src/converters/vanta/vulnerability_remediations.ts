import {AirbyteRecord} from 'faros-airbyte-cdk';
import {VulnerabilityRemediation} from 'faros-airbyte-common/vanta';
import {Utils} from 'faros-js-client';

import {ArtifactKey} from '../common/cicd';
import {DestinationModel, DestinationRecord, StreamContext} from '../converter';
import {VantaConverter, VcsRepoKey} from './common';
import {getQueryFromName} from './utils';

export abstract class VulnerabilityRemediations extends VantaConverter {
  readonly destinationModels: ReadonlyArray<DestinationModel> = [];
  readonly vulnerabilitiesWithoutAsset = new Set<string>();
  readonly vulnerabilitiesWithoutSupportedAsset = new Set<string>();

  private readonly vcsRepositoryVulnerabilityQuery = getQueryFromName(
    'vcsRepositoryVulnerabilityQuery'
  );
  private readonly cicdArtifactVulnerabilityQuery = getQueryFromName(
    'cicdArtifactVulnerabilityQuery'
  );
  private readonly vcsVulnsToUpdate = new Set<string>();
  private readonly cicdVulnsToUpdate = new Set<string>();
  private readonly vulnIdToResolutionTime = new Map<string, Date>();

  async convert(
    record: AirbyteRecord
  ): Promise<ReadonlyArray<DestinationRecord>> {
    const vulnerabilityRemediation = record?.record
      ?.data as VulnerabilityRemediation;
    // We create sec_Vulnerability per finding, not per unique vulnerability.
    // So sec_Vulnerability will be tied either to one vcs_RepositoryVulnerability or cicd_ArtifactVulnerability.
    // If the remediation is not tied to any asset, we skip it.
    if (!vulnerabilityRemediation.asset) {
      this.vulnerabilitiesWithoutAsset.add(vulnerabilityRemediation.id);
      return [];
    }
    if (this.isVCSRepoVulnerability(vulnerabilityRemediation.asset)) {
      this.vcsVulnsToUpdate.add(vulnerabilityRemediation.vulnerabilityId);
      this.vulnIdToResolutionTime.set(
        vulnerabilityRemediation.vulnerabilityId,
        Utils.toDate(vulnerabilityRemediation.remediationDate)
      );
      return [];
    } else if (
      this.isCICDArtifactVulnerability(vulnerabilityRemediation.asset)
    ) {
      this.cicdVulnsToUpdate.add(vulnerabilityRemediation.vulnerabilityId);
      this.vulnIdToResolutionTime.set(
        vulnerabilityRemediation.vulnerabilityId,
        Utils.toDate(vulnerabilityRemediation.remediationDate)
      );
      return [];
    }
    this.vulnerabilitiesWithoutSupportedAsset.add(vulnerabilityRemediation.id);
    return [];
  }

  private async updateVulnerabilities(
    ctx: StreamContext
  ): Promise<DestinationRecord[]> {
    const records: DestinationRecord[] = [];
    const repoKeys: Record<string, VcsRepoKey[]> =
      await this.getBatchedRepoKeysFromVulnerability(
        this.vcsVulnsToUpdate,
        ctx
      );
    for (const vulnerabilityId in repoKeys) {
      if (!repoKeys[vulnerabilityId] || repoKeys[vulnerabilityId].length === 0) {
        continue;
      }
      for (const repoKey of repoKeys[vulnerabilityId]) {
        records.push({
          model: 'vcs_RepositoryVulnerability__Update',
          record: {
            where: {
              vulnerability: {
                uid: vulnerabilityId,
                source: this.source,
              },
              repository: repoKey,
            },
            mask: ['resolvedAt', 'status'],
            patch: {
              resolvedAt: this.vulnIdToResolutionTime.get(vulnerabilityId),
              status: {
                category: 'Resolved',
                detail: 'Resolved',
              },
            },
          },
        });
      }
    }
    const artifactKeys: Record<string, ArtifactKey[]> =
      await this.getBatchedArtifactKeysFromVulnerability(
        this.cicdVulnsToUpdate,
        ctx
      );
    for (const vulnerabilityId in artifactKeys) {
      if (!artifactKeys[vulnerabilityId] || artifactKeys[vulnerabilityId].length === 0) {
        continue;
      }
      for (const artifactKey of artifactKeys[vulnerabilityId]) {
        records.push({
          model: 'cicd_ArtifactVulnerability__Update',
          record: {
            where: {
              vulnerability: {
                uid: vulnerabilityId,
                source: this.source,
              },
              artifact: artifactKey,
            },
            mask: ['resolvedAt', 'status'],
            patch: {
              resolvedAt: this.vulnIdToResolutionTime.get(vulnerabilityId),
              status: {
                category: 'Resolved',
                detail: 'Resolved',
              },
            },
          },
        });
      }
    }
    return records;
  }

  async onProcessingComplete(
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    this.logVulnerabilityWarnings(
      ctx,
      this.vulnerabilitiesWithoutAsset,
      'Vulnerability remediations without an asset associated found'
    );
    this.logVulnerabilityWarnings(
      ctx,
      this.vulnerabilitiesWithoutSupportedAsset,
      'Vulnerability remediations with no supported vulnerable asset found'
    );
    const records = await this.updateVulnerabilities(ctx);
    return records;
  }

  protected async getBatchedRepoKeysFromVulnerability(
    vulnerabilityIds: Set<string>,
    ctx: StreamContext,
    batchSize: number = 20
  ): Promise<Record<string, VcsRepoKey[]>> {
    if (vulnerabilityIds.size === 0) {
      return {};
    }
    ctx.logger.info(
      `Getting repo keys for ${vulnerabilityIds.size} vulnerabilities`
    );

    const allResults: Record<string, VcsRepoKey[]> = {};

    // Process in batches
    for (let i = 0; i < vulnerabilityIds.size; i += batchSize) {
      const batch = Array.from(vulnerabilityIds).slice(i, i + batchSize);
      const result = await ctx.farosClient.gql(
        ctx.graph,
        this.vcsRepositoryVulnerabilityQuery,
        {
          vulnerabilityIds: batch,
        }
      );
      ctx.logger.info(
        `Got ${result?.vcs_RepositoryVulnerability?.length} repo keys`
      );
      for (const item of result?.vcs_RepositoryVulnerability || []) {
        if (
          item?.repository?.name &&
          item?.repository?.organization?.uid &&
          item?.repository?.organization?.source
        ) {
          if (!allResults[item.vulnerability.uid]) {
            allResults[item.vulnerability.uid] = [];
          }
          allResults[item.vulnerability.uid].push({
            name: item.repository.name,
            organization: {
              uid: item.repository.organization.uid,
              source: item.repository.organization.source,
            },
          });
        }
      }
    }
    ctx.logger.info(`Got ${Object.keys(allResults).length} repo keys`);
    return allResults;
  }

  protected async getBatchedArtifactKeysFromVulnerability(
    vulnerabilityIds: Set<string>,
    ctx: StreamContext,
    batchSize: number = 20
  ): Promise<Record<string, ArtifactKey[]>> {
    if (vulnerabilityIds.size === 0) {
      return {};
    }
    ctx.logger.info(
      `Getting artifact keys for ${vulnerabilityIds.size} vulnerabilities`
    );

    const allResults: Record<string, ArtifactKey[]> = {};

    // Process in batches
    for (let i = 0; i < vulnerabilityIds.size; i += batchSize) {
      const batch = Array.from(vulnerabilityIds).slice(i, i + batchSize);

      const result = await ctx.farosClient.gql(
        ctx.graph,
        this.cicdArtifactVulnerabilityQuery,
        {
          vulnerabilityIds: batch,
        }
      );
      ctx.logger.info(
        `Got ${result?.cicd_ArtifactVulnerability?.length} artifact keys`
      );

      for (const item of result?.cicd_ArtifactVulnerability || []) {
        if (
          item?.artifact?.uid &&
          item?.artifact?.repository?.uid &&
          item?.artifact?.repository?.organization?.uid &&
          item?.artifact?.repository?.organization?.source
        ) {
          if (!allResults[item.vulnerability.uid]) {
            allResults[item.vulnerability.uid] = [];
          }
          allResults[item.vulnerability.uid].push({
            uid: item.artifact.uid,
            repository: {
              uid: item.artifact.repository.uid,
              organization: {
                uid: item.artifact.repository.organization.uid,
                source: item.artifact.repository.organization.source,
              },
            },
          });
        }
      }
    }
    ctx.logger.info(`Got ${Object.keys(allResults).length} artifact keys`);
    return allResults;
  }
}
