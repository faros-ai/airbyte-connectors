import {AirbyteRecord} from 'faros-airbyte-cdk';
import {VulnerabilityRemediation} from 'faros-airbyte-common/vanta';
import {Utils} from 'faros-js-client';

import {DestinationModel, DestinationRecord, StreamContext} from '../converter';
import {VantaConverter} from './common';

export abstract class VulnerabilityRemediations extends VantaConverter {
  readonly destinationModels: ReadonlyArray<DestinationModel> = [];
  readonly vulnerabilitiesWithoutAsset = new Set<string>();
  readonly vulnerabilitiesWithoutSupportedAsset = new Set<string>();

  async convert(
    record: AirbyteRecord,
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    const vulnerabilityRemediation = record?.record
      ?.data as VulnerabilityRemediation;
    // We create sec_Vulnerability per finding, not per unique vulnerability.
    // So sec_Vulnerability will be tied either to one vcs_RepositoryVulnerability or cicd_ArtifactVulnerability.
    // If the remediation is not tied to any asset, we skip it.
    if (!vulnerabilityRemediation.asset) {
      this.vulnerabilitiesWithoutAsset.add(vulnerabilityRemediation.id);
      return [];
    }
    if (this.isVCSRepoVulnerability(vulnerabilityRemediation.asset)) {
      if (
        vulnerabilityRemediation.vulnerabilityId ==
        '6570fb9753612158fb70681378279fe5e38d4b9e'
      ) {
        ctx.logger.warn(`Found the important remediation...`);
      }
      return [
        {
          model: 'vcs_RepositoryVulnerability__Update',
          record: {
            where: {
              vulnerability: {
                uid: vulnerabilityRemediation.vulnerabilityId,
                source: this.source,
              },
              repository: {
                name: vulnerabilityRemediation.asset.name,
              },
            },
            mask: ['resolvedAt', 'status'],
            patch: {
              resolvedAt: Utils.toDate(
                vulnerabilityRemediation.remediationDate
              ),
              status: {
                category: 'Resolved',
                detail: 'Resolved',
              },
            },
          },
        },
      ];
    } else if (
      this.isCICDArtifactVulnerability(vulnerabilityRemediation.asset)
    ) {
      return [
        {
          model: 'cicd_ArtifactVulnerability__Update',
          record: {
            where: {
              vulnerability: {
                uid: vulnerabilityRemediation.vulnerabilityId,
                source: this.source,
              },
              artifact: {
                uid: this.getCommitSha(
                  vulnerabilityRemediation.asset.imageTags
                ),
              },
            },
            mask: ['resolvedAt', 'status'],
            patch: {
              resolvedAt: Utils.toDate(
                vulnerabilityRemediation.remediationDate
              ),
              status: {
                category: 'Resolved',
                detail: 'Resolved',
              },
            },
          },
        },
      ];
    }
    this.vulnerabilitiesWithoutSupportedAsset.add(vulnerabilityRemediation.id);
    return [];
  }

  async onProcessingComplete(
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    this.logVulnerabilityWarnings(
      ctx,
      this.vulnerabilitiesWithoutAsset,
      'Vulnerability remediations without an asset associated found'
    );
    this.logVulnerabilityWarnings(
      ctx,
      this.vulnerabilitiesWithoutSupportedAsset,
      'Vulnerability remediations with no supported vulnerable asset found'
    );
    return [];
  }
}
