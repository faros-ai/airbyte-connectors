import {AirbyteRecord} from 'faros-airbyte-cdk';
import {VulnerabilityRemediation} from 'faros-airbyte-common/vanta';

import {
  Converter,
  DestinationModel,
  DestinationRecord,
  StreamContext,
} from '../converter';
import {getQueryFromName} from './utils';

export abstract class VulnerabilityRemediations extends Converter {
  source = 'vanta';
  readonly destinationModels: ReadonlyArray<DestinationModel> = [];
  severityMap: {[key: string]: number} = {
    LOW: 3.0,
    MEDIUM: 6.0,
    HIGH: 9.0,
    CRITICAL: 10.0,
  };
  secVulnerabilityQuery = getQueryFromName('secVulnerabilityQuery');

  /** All Vanta records should have id property */
  id(record: AirbyteRecord): any {
    return record?.record?.data?.data.id;
  }

  async convert(
    record: AirbyteRecord,
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    return this.convertVulnerabilityRemediationRecord(
      record?.record?.data.data,
      ctx
    );
  }

  async convertVulnerabilityRemediationRecord(
    data: VulnerabilityRemediation,
    ctx: StreamContext
  ): Promise<ReadonlyArray<DestinationRecord>> {
    const relatedEntity = await this.getVulnerabilityRelatedEntityById(
      data.vulnerabilityId,
      ctx
    );
    if (!relatedEntity) {
      ctx.logger.warn(
        `No related entity found for vulnerability id ${data.vulnerabilityId}`
      );
      return [];
    }
    if (relatedEntity.repository) {
      return [
        {
          model: 'vcs_RepositoryVulnerability__Update',
          record: {
            at: Date.now(),
            where: {
              vulnerability: {
                uid: data.vulnerabilityId,
                source: this.source,
              },
              repository: {
                name: relatedEntity.repository.name,
                organization: {
                  uid: relatedEntity.repository.organization.uid,
                  source: relatedEntity.repository.organization.source,
                },
              },
            },
            mask: ['resolvedAt', 'status'],
            patch: {
              resolvedAt: data.remediationDate,
              status: {
                category: 'Resolved',
                detail: 'Resolved',
              },
            },
          },
        },
      ];
    }
    if (relatedEntity.artifact) {
      return [
        {
          model: 'cicd_ArtifactVulnerability__Update',
          record: {
            at: Date.now(),
            where: {
              vulnerability: {
                uid: data.vulnerabilityId,
                source: this.source,
              },
              artifact: {
                uid: relatedEntity.artifact.uid,
                repository: {
                  uid: relatedEntity.artifact.repository.uid,
                  organization: {
                    uid: relatedEntity.artifact.repository.organization.uid,
                    source:
                      relatedEntity.artifact.repository.organization.source,
                  },
                },
              },
            },
            mask: ['resolvedAt', 'status'],
            patch: {
              resolvedAt: data.remediationDate,
              status: {
                category: 'Resolved',
                detail: 'Resolved',
              },
            },
          },
        },
      ];
    }
  }

  /** Sec vulnerability has artifacts and repository relationship. When source is Vanta, each sec vulnerability will have only
   * one cicd artifact or vcs repository, as it represents a finding. **/
  async getVulnerabilityRelatedEntityById(
    id: string,
    ctx: StreamContext
  ): Promise<any> {
    const result = await ctx.farosClient.gql(
      ctx.graph,
      this.secVulnerabilityQuery,
      {id, source: this.source}
    );
    const artifacts = result?.sec_Vulnerability[0]?.artifacts;
    const repositories = result?.sec_Vulnerability[0]?.repositories;
    if (artifacts && artifacts.length > 0) {
      return artifacts[0];
    } else if (repositories && repositories.length > 0) {
      return repositories[0];
    }
  }
}
